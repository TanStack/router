{"hash":"93442caf770a0ea8e26b5b119f0900e9c230f65ed37e585e357ad77480b3791f","types":[{"exports":["AnyRootRoute","AnyRouter","ErrorRouteComponent","InjectBlockerOpts","InjectLoaderDataBaseOptions","InjectLoaderDataOptions","InjectLoaderDataRoute","InjectLoaderDepsBaseOptions","InjectLoaderDepsOptions","InjectLoaderDepsRoute","InjectLocationOptions","InjectLocationResult","InjectMatchBaseOptions","InjectMatchOptions","InjectMatchResult","InjectMatchRoute","InjectNavigateResult","InjectParamsBaseOptions","InjectParamsOptions","InjectParamsRoute","InjectRouteContextRoute","InjectRouterResult","InjectRouterStateOptions","InjectRouterStateResult","InjectSearchBaseOptions","InjectSearchOptions","InjectSearchRoute","LinkInputOptions","LinkOptions","MATCH_ID_INJECTOR_TOKEN","Matches","NavigateOptions","NotFoundRoute","NotFoundRouteComponent","Outlet","RegisteredRouter","RootRoute","RootRouteOptions","Route","RouteApi","RouteComponent","RouteMatch","RouteOptions","RouterProvider","RouterState","ShouldBlockFn","UseBlockerOpts","createRootRoute","createRootRouteWithContext","createRoute","createRouteMask","createRouter","getRouteApi","getRouterInjectionKey","injectBlocker","injectCanGoBack","injectDynamicRenderer","injectIntersectionObserver","injectLoaderData","injectLoaderDeps","injectLocation","injectMatch","injectNavigate","injectParams","injectRouter","injectRouterContext","injectRouterState","injectSearch","rootRouteWithContext"],"facadeModuleId":"/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/tanstack-angular-router.d.ts","isDynamicEntry":false,"isEntry":true,"isImplicitEntry":false,"moduleIds":["/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/injectLoaderData.d.ts","/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/injectMatch.d.ts","/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/injectLoaderDeps.d.ts","/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/injectParams.d.ts","/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/injectSearch.d.ts","/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/injectRouteContext.d.ts","/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/route.d.ts","/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/router.d.ts","/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/RouterProvider.d.ts","/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/Match.d.ts","/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/Macthes.d.ts","/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/injectRouter.d.ts","/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/injectRouterState.d.ts","/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/injectNavigate.d.ts","/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/injectLocationResult.d.ts","/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/injectBlocker.d.ts","/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/injectCanGoBack.d.ts","/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/Link.d.ts","/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/injectIntersectionObserver.d.ts","/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/dynamicRenderer.d.ts","/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/routerInjectionToken.d.ts","/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/matchInjectorToken.d.ts","/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/tanstack-angular-router.d.ts"],"name":"tanstack-angular-router.d","type":"chunk","dynamicImports":[],"fileName":"tanstack-angular-router.d.ts","implicitlyLoadedBefore":[],"importedBindings":{"@tanstack/router-core":["AnyRouter","RegisteredRouter","ResolveUseLoaderData","UseLoaderDataResult","StrictOrFrom","MakeRouteMatch","MakeRouteMatchUnion","ThrowConstraint","ThrowOrOptional","ResolveUseLoaderDeps","UseLoaderDepsResult","ResolveUseParams","UseParamsResult","ResolveUseSearch","UseSearchResult","UseRouteContextBaseOptions","UseRouteContextResult","UseRouteContextOptions","UseNavigateResult","RouteConstraints","AnyRoute","ResolveFullPath","ResolveId","ResolveParams","AnyContext","RouteOptions","BaseRoute","Route","Register","RootRouteOptions","BaseRootRoute","RootRoute","RootRouteId","ToMaskOptions","RouterCore","RouteMask","ConstrainLiteral","RouteIds","BaseRouteApi","RouteTypesById","NotFoundError","CreateRouterFn","*","RouterState","FromPathOption","ParseRoute","RoutePaths","LinkOptions","NavigateOptions"],"@angular/core":["Signal","Type","*","Provider","InjectionToken"],"@tanstack/angular-router":["*"],"@tanstack/history":["HistoryAction"]},"imports":["@tanstack/router-core","@angular/core","@tanstack/angular-router","@tanstack/history"],"modules":{"/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/injectLoaderData.d.ts":{"code":"interface InjectLoaderDataBaseOptions<TRouter extends AnyRouter, TFrom, TStrict extends boolean, TSelected> {\n    select?: (match: ResolveUseLoaderData<TRouter, TFrom, TStrict>) => TSelected;\n}\ntype InjectLoaderDataOptions<TRouter extends AnyRouter, TFrom extends string | undefined, TStrict extends boolean, TSelected> = StrictOrFrom<TRouter, TFrom, TStrict> & InjectLoaderDataBaseOptions<TRouter, TFrom, TStrict, TSelected>;\ntype InjectLoaderDataRoute<out TFrom> = <TRouter extends AnyRouter = RegisteredRouter, TSelected = unknown>(opts?: InjectLoaderDataBaseOptions<TRouter, TFrom, true, TSelected>) => Signal<UseLoaderDataResult<TRouter, TFrom, true, TSelected>>;\ndeclare function injectLoaderData<TRouter extends AnyRouter = RegisteredRouter, const TFrom extends string | undefined = undefined, TStrict extends boolean = true, TSelected = unknown>(opts: InjectLoaderDataOptions<TRouter, TFrom, TStrict, TSelected>): Signal<UseLoaderDataResult<TRouter, TFrom, TStrict, TSelected>>;","originalLength":1227,"removedExports":[],"renderedExports":["InjectLoaderDataBaseOptions","InjectLoaderDataOptions","InjectLoaderDataRoute","injectLoaderData"],"renderedLength":986},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/injectMatch.d.ts":{"code":"interface InjectMatchBaseOptions<TRouter extends AnyRouter, TFrom, TStrict extends boolean, TThrow extends boolean, TSelected> {\n    select?: (match: MakeRouteMatch<TRouter['routeTree'], TFrom, TStrict>) => TSelected;\n    shouldThrow?: TThrow;\n}\ntype InjectMatchOptions<TRouter extends AnyRouter, TFrom, TStrict extends boolean, TThrow extends boolean, TSelected> = StrictOrFrom<TRouter, TFrom, TStrict> & InjectMatchBaseOptions<TRouter, TFrom, TStrict, TThrow, TSelected>;\ntype InjectMatchResult<TRouter extends AnyRouter, TFrom, TStrict extends boolean, TSelected> = unknown extends TSelected ? TStrict extends true ? MakeRouteMatch<TRouter['routeTree'], TFrom, TStrict> : MakeRouteMatchUnion<TRouter> : TSelected;\ntype InjectMatchRoute<out TFrom> = <TRouter extends AnyRouter = RegisteredRouter, TSelected = unknown>(opts?: InjectMatchBaseOptions<TRouter, TFrom, true, true, TSelected>) => Signal<InjectMatchResult<TRouter, TFrom, true, TSelected>>;\ndeclare function injectMatch<TRouter extends AnyRouter = RegisteredRouter, const TFrom extends string | undefined = undefined, TStrict extends boolean = true, TThrow extends boolean = true, TSelected = unknown>(opts: InjectMatchOptions<TRouter, TFrom, TStrict, ThrowConstraint<TStrict, TThrow>, TSelected>): Signal<ThrowOrOptional<InjectMatchResult<TRouter, TFrom, TStrict, TSelected>, TThrow>>;","originalLength":1619,"removedExports":[],"renderedExports":["InjectMatchBaseOptions","InjectMatchOptions","InjectMatchResult","InjectMatchRoute","injectMatch"],"renderedLength":1348},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/injectLoaderDeps.d.ts":{"code":"interface InjectLoaderDepsBaseOptions<TRouter extends AnyRouter, TFrom, TSelected> {\n    select?: (deps: ResolveUseLoaderDeps<TRouter, TFrom>) => TSelected;\n}\ntype InjectLoaderDepsOptions<TRouter extends AnyRouter, TFrom extends string | undefined, TSelected> = StrictOrFrom<TRouter, TFrom> & InjectLoaderDepsBaseOptions<TRouter, TFrom, TSelected>;\ntype InjectLoaderDepsRoute<out TFrom> = <TRouter extends AnyRouter = RegisteredRouter, TSelected = unknown>(opts?: InjectLoaderDepsBaseOptions<TRouter, TFrom, TSelected>) => Signal<UseLoaderDepsResult<TRouter, TFrom, TSelected>>;\ndeclare function injectLoaderDeps<TRouter extends AnyRouter = RegisteredRouter, const TFrom extends string | undefined = undefined, TSelected = unknown>(opts: InjectLoaderDepsOptions<TRouter, TFrom, TSelected>): Signal<UseLoaderDepsResult<TRouter, TFrom, TSelected>>;","originalLength":1087,"removedExports":[],"renderedExports":["InjectLoaderDepsBaseOptions","InjectLoaderDepsOptions","InjectLoaderDepsRoute","injectLoaderDeps"],"renderedLength":846},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/injectParams.d.ts":{"code":"interface InjectParamsBaseOptions<TRouter extends AnyRouter, TFrom, TStrict extends boolean, TThrow extends boolean, TSelected> {\n    select?: (params: ResolveUseParams<TRouter, TFrom, TStrict>) => TSelected;\n    shouldThrow?: TThrow;\n}\ntype InjectParamsOptions<TRouter extends AnyRouter, TFrom extends string | undefined, TStrict extends boolean, TThrow extends boolean, TSelected> = StrictOrFrom<TRouter, TFrom, TStrict> & InjectParamsBaseOptions<TRouter, TFrom, TStrict, TThrow, TSelected>;\ntype InjectParamsRoute<out TFrom> = <TRouter extends AnyRouter = RegisteredRouter, TSelected = unknown>(opts?: InjectParamsBaseOptions<TRouter, TFrom, true, true, TSelected>) => Signal<UseParamsResult<TRouter, TFrom, true, TSelected>>;\ndeclare function injectParams<TRouter extends AnyRouter = RegisteredRouter, const TFrom extends string | undefined = undefined, TStrict extends boolean = true, TThrow extends boolean = true, TSelected = unknown>(opts: InjectParamsOptions<TRouter, TFrom, TStrict, ThrowConstraint<TStrict, TThrow>, TSelected>): Signal<ThrowOrOptional<UseParamsResult<TRouter, TFrom, true, TSelected>, TThrow>>;","originalLength":1395,"removedExports":[],"renderedExports":["InjectParamsBaseOptions","InjectParamsOptions","InjectParamsRoute","injectParams"],"renderedLength":1122},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/injectSearch.d.ts":{"code":"interface InjectSearchBaseOptions<TRouter extends AnyRouter, TFrom, TStrict extends boolean, TThrow extends boolean, TSelected> {\n    select?: (state: ResolveUseSearch<TRouter, TFrom, TStrict>) => TSelected;\n    shouldThrow?: TThrow;\n}\ntype InjectSearchOptions<TRouter extends AnyRouter, TFrom, TStrict extends boolean, TThrow extends boolean, TSelected> = StrictOrFrom<TRouter, TFrom, TStrict> & InjectSearchBaseOptions<TRouter, TFrom, TStrict, TThrow, TSelected>;\ntype InjectSearchRoute<out TFrom> = <TRouter extends AnyRouter = RegisteredRouter, TSelected = unknown>(opts?: InjectSearchBaseOptions<TRouter, TFrom, true, true, TSelected>) => Signal<UseSearchResult<TRouter, TFrom, true, TSelected>>;\ndeclare function injectSearch<TRouter extends AnyRouter = RegisteredRouter, const TFrom extends string | undefined = undefined, TStrict extends boolean = true, TThrow extends boolean = true, TSelected = unknown>(opts: InjectSearchOptions<TRouter, TFrom, TStrict, ThrowConstraint<TStrict, TThrow>, TSelected>): Signal<ThrowOrOptional<UseSearchResult<TRouter, TFrom, TStrict, TSelected>, TThrow>>;","originalLength":1370,"removedExports":[],"renderedExports":["InjectSearchBaseOptions","InjectSearchOptions","InjectSearchRoute","injectSearch"],"renderedLength":1097},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/injectRouteContext.d.ts":{"code":"type InjectRouteContextRoute<out TFrom> = <TRouter extends AnyRouter = RegisteredRouter, TSelected = unknown>(opts?: UseRouteContextBaseOptions<TRouter, TFrom, true, TSelected>) => Signal<UseRouteContextResult<TRouter, TFrom, true, TSelected>>;\ndeclare function injectRouterContext<TRouter extends AnyRouter = RegisteredRouter, const TFrom extends string | undefined = undefined, TStrict extends boolean = true, TSelected = unknown>(opts: UseRouteContextOptions<TRouter, TFrom, TStrict, TSelected>): Signal<UseRouteContextResult<TRouter, TFrom, TStrict, TSelected>>;","originalLength":823,"removedExports":[],"renderedExports":["InjectRouteContextRoute","injectRouterContext"],"renderedLength":566},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/route.d.ts":{"code":"declare module '@tanstack/router-core' {\n    interface UpdatableRouteOptionsExtensions {\n        component?: RouteComponent;\n        errorComponent?: false | null | undefined | ErrorRouteComponent;\n        notFoundComponent?: NotFoundRouteComponent;\n        pendingComponent?: RouteComponent;\n    }\n    interface RootRouteOptionsExtensions {\n        shellComponent?: Type<{\n            children: any;\n        }>;\n    }\n    interface RouteExtensions<in out TId extends string, in out TFullPath extends string> {\n        injectMatch: InjectMatchRoute<TId>;\n        injectRouteContext: InjectRouteContextRoute<TId>;\n        injectSearch: InjectSearchRoute<TId>;\n        injectParams: InjectParamsRoute<TId>;\n        injectLoaderDeps: InjectLoaderDepsRoute<TId>;\n        injectLoaderData: InjectLoaderDataRoute<TId>;\n        injectNavigate: () => UseNavigateResult<TFullPath>;\n    }\n};\ndeclare function getRouteApi<const TId, TRouter extends AnyRouter = RegisteredRouter>(id: ConstrainLiteral<TId, RouteIds<TRouter['routeTree']>>): RouteApi<TId, TRouter>;\ndeclare class RouteApi<TId, TRouter extends AnyRouter = RegisteredRouter> extends BaseRouteApi<TId, TRouter> {\n    /**\n     * @deprecated Use the `getRouteApi` function instead.\n     */\n    constructor({ id }: {\n        id: TId;\n    });\n    injectMatch: InjectMatchRoute<TId>;\n    injectRouteContext: InjectRouteContextRoute<TId>;\n    injectSearch: InjectSearchRoute<TId>;\n    injectParams: InjectParamsRoute<TId>;\n    injectLoaderDeps: InjectLoaderDepsRoute<TId>;\n    injectLoaderData: InjectLoaderDataRoute<TId>;\n    injectNavigate: () => UseNavigateResult<RouteTypesById<TRouter, TId>[\"fullPath\"]>;\n    notFound: (opts?: NotFoundError) => NotFoundError;\n}\ndeclare class Route<in out TRegister = unknown, in out TParentRoute extends RouteConstraints['TParentRoute'] = AnyRoute, in out TPath extends RouteConstraints['TPath'] = '/', in out TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<TParentRoute, TPath>, in out TCustomId extends RouteConstraints['TCustomId'] = string, in out TId extends RouteConstraints['TId'] = ResolveId<TParentRoute, TCustomId, TPath>, in out TSearchValidator = undefined, in out TParams = ResolveParams<TPath>, in out TRouterContext = AnyContext, in out TRouteContextFn = AnyContext, in out TBeforeLoadFn = AnyContext, in out TLoaderDeps extends Record<string, any> = {}, in out TLoaderFn = undefined, in out TChildren = unknown, in out TFileRouteTypes = unknown, in out TSSR = unknown, in out TMiddlewares = unknown, in out THandlers = undefined> extends BaseRoute<TRegister, TParentRoute, TPath, TFullPath, TCustomId, TId, TSearchValidator, TParams, TRouterContext, TRouteContextFn, TBeforeLoadFn, TLoaderDeps, TLoaderFn, TChildren, TFileRouteTypes, TSSR, TMiddlewares, THandlers> implements Route$1<TRegister, TParentRoute, TPath, TFullPath, TCustomId, TId, TSearchValidator, TParams, TRouterContext, TRouteContextFn, TBeforeLoadFn, TLoaderDeps, TLoaderFn, TChildren, TFileRouteTypes, TSSR, TMiddlewares, THandlers> {\n    /**\n     * @deprecated Use the `createRoute` function instead.\n     */\n    constructor(options?: RouteOptions<TRegister, TParentRoute, TId, TCustomId, TFullPath, TPath, TSearchValidator, TParams, TLoaderDeps, TLoaderFn, TRouterContext, TRouteContextFn, TBeforeLoadFn, TSSR, TMiddlewares, THandlers>);\n    injectMatch: InjectMatchRoute<TId>;\n    injectRouteContext: InjectRouteContextRoute<TId>;\n    injectSearch: InjectSearchRoute<TId>;\n    injectParams: InjectParamsRoute<TId>;\n    injectLoaderDeps: InjectLoaderDepsRoute<TId>;\n    injectLoaderData: InjectLoaderDataRoute<TId>;\n    injectNavigate: () => UseNavigateResult<TFullPath>;\n}\ndeclare function createRoute<TRegister = unknown, TParentRoute extends RouteConstraints['TParentRoute'] = AnyRoute, TPath extends RouteConstraints['TPath'] = '/', TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<TParentRoute, TPath>, TCustomId extends RouteConstraints['TCustomId'] = string, TId extends RouteConstraints['TId'] = ResolveId<TParentRoute, TCustomId, TPath>, TSearchValidator = undefined, TParams = ResolveParams<TPath>, TRouteContextFn = AnyContext, TBeforeLoadFn = AnyContext, TLoaderDeps extends Record<string, any> = {}, TLoaderFn = undefined, TChildren = unknown, TSSR = unknown, THandlers = undefined>(options: RouteOptions<TRegister, TParentRoute, TId, TCustomId, TFullPath, TPath, TSearchValidator, TParams, TLoaderDeps, TLoaderFn, AnyContext, TRouteContextFn, TBeforeLoadFn, TSSR, THandlers>): Route<TRegister, TParentRoute, TPath, TFullPath, TCustomId, TId, TSearchValidator, TParams, AnyContext, TRouteContextFn, TBeforeLoadFn, TLoaderDeps, TLoaderFn, TChildren, unknown, TSSR, THandlers>;\ntype AnyRootRoute = RootRoute<any, any, any, any, any, any, any, any, any, any>;\ndeclare function createRootRouteWithContext<TRouterContext extends {}>(): <TRegister = Register, TRouteContextFn = AnyContext, TBeforeLoadFn = AnyContext, TSearchValidator = undefined, TLoaderDeps extends Record<string, any> = {}, TLoaderFn = undefined, TSSR = unknown, THandlers = undefined>(options?: RootRouteOptions<TRegister, TSearchValidator, TRouterContext, TRouteContextFn, TBeforeLoadFn, TLoaderDeps, TLoaderFn, TSSR, THandlers>) => RootRoute<TRegister, TSearchValidator, TRouterContext, TRouteContextFn, TBeforeLoadFn, TLoaderDeps, TLoaderFn, unknown, unknown, TSSR, THandlers>;\n/**\n * @deprecated Use the `createRootRouteWithContext` function instead.\n */\ndeclare const rootRouteWithContext: typeof createRootRouteWithContext;\ndeclare class RootRoute<in out TRegister = Register, in out TSearchValidator = undefined, in out TRouterContext = {}, in out TRouteContextFn = AnyContext, in out TBeforeLoadFn = AnyContext, in out TLoaderDeps extends Record<string, any> = {}, in out TLoaderFn = undefined, in out TChildren = unknown, in out TFileRouteTypes = unknown, in out TSSR = unknown, in out THandlers = undefined> extends BaseRootRoute<TRegister, TSearchValidator, TRouterContext, TRouteContextFn, TBeforeLoadFn, TLoaderDeps, TLoaderFn, TChildren, TFileRouteTypes, TSSR, THandlers> implements RootRoute$1<TRegister, TSearchValidator, TRouterContext, TRouteContextFn, TBeforeLoadFn, TLoaderDeps, TLoaderFn, TChildren, TFileRouteTypes, TSSR, THandlers> {\n    /**\n     * @deprecated `RootRoute` is now an internal implementation detail. Use `createRootRoute()` instead.\n     */\n    constructor(options?: RootRouteOptions<TRegister, TSearchValidator, TRouterContext, TRouteContextFn, TBeforeLoadFn, TLoaderDeps, TLoaderFn, TSSR, THandlers>);\n    injectMatch: InjectMatchRoute<RootRouteId>;\n    injectRouteContext: InjectRouteContextRoute<RootRouteId>;\n    injectSearch: InjectSearchRoute<RootRouteId>;\n    injectParams: InjectParamsRoute<RootRouteId>;\n    injectLoaderDeps: InjectLoaderDepsRoute<RootRouteId>;\n    injectLoaderData: InjectLoaderDataRoute<RootRouteId>;\n    injectNavigate: () => UseNavigateResult<\"/\">;\n}\ndeclare function createRouteMask<TRouteTree extends AnyRoute, TFrom extends string, TTo extends string>(opts: {\n    routeTree: TRouteTree;\n} & ToMaskOptions<RouterCore<TRouteTree, 'never', false>, TFrom, TTo>): RouteMask<TRouteTree>;\ntype RouteComponent<TComponent = unknown> = Type<TComponent>;\ntype ErrorRouteComponent = Type<unknown>;\ntype NotFoundRouteComponent = Type<unknown>;\ndeclare class NotFoundRoute<TRegister, TParentRoute extends AnyRootRoute, TRouterContext = AnyContext, TRouteContextFn = AnyContext, TBeforeLoadFn = AnyContext, TSearchValidator = undefined, TLoaderDeps extends Record<string, any> = {}, TLoaderFn = undefined, TChildren = unknown, TSSR = unknown, THandlers = undefined> extends Route<TRegister, TParentRoute, '/404', '/404', '404', '404', TSearchValidator, {}, TRouterContext, TRouteContextFn, TBeforeLoadFn, TLoaderDeps, TLoaderFn, TChildren, TSSR, THandlers> {\n    constructor(options: Omit<RouteOptions<TRegister, TParentRoute, string, string, string, string, TSearchValidator, {}, TLoaderDeps, TLoaderFn, TRouterContext, TRouteContextFn, TBeforeLoadFn, TSSR, THandlers>, 'caseSensitive' | 'parseParams' | 'stringifyParams' | 'path' | 'id' | 'params'>);\n}\ndeclare function createRootRoute<TRegister = Register, TSearchValidator = undefined, TRouterContext = {}, TRouteContextFn = AnyContext, TBeforeLoadFn = AnyContext, TLoaderDeps extends Record<string, any> = {}, TLoaderFn = undefined, TSSR = unknown, THandlers = undefined>(options?: RootRouteOptions<TRegister, TSearchValidator, TRouterContext, TRouteContextFn, TBeforeLoadFn, TLoaderDeps, TLoaderFn, TSSR, THandlers>): RootRoute<TRegister, TSearchValidator, TRouterContext, TRouteContextFn, TBeforeLoadFn, TLoaderDeps, TLoaderFn, unknown, unknown, TSSR, THandlers>;","originalLength":9663,"removedExports":[],"renderedExports":["getRouteApi","RouteApi","Route","createRoute","AnyRootRoute","createRootRouteWithContext","rootRouteWithContext","RootRoute","createRouteMask","RouteComponent","ErrorRouteComponent","NotFoundRouteComponent","NotFoundRoute","createRootRoute"],"renderedLength":8659},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/router.d.ts":{"code":"declare module '@tanstack/router-core' {\n    interface RouterOptionsExtensions {\n        /**\n         * The default `component` a route should use if no component is provided.\n         *\n         * @default Outlet\n         * @link [API Docs](https://tanstack.com/router/latest/docs/framework/solid/api/router/RouterOptionsType#defaultcomponent-property)\n         */\n        defaultComponent?: RouteComponent;\n        /**\n         * The default `errorComponent` a route should use if no error component is provided.\n         *\n         * @default ErrorComponent\n         * @link [API Docs](https://tanstack.com/router/latest/docs/framework/solid/api/router/RouterOptionsType#defaulterrorcomponent-property)\n         * @link [Guide](https://tanstack.com/router/latest/docs/framework/solid/guide/data-loading#handling-errors-with-routeoptionserrorcomponent)\n         */\n        defaultErrorComponent?: ErrorRouteComponent;\n        /**\n         * The default `pendingComponent` a route should use if no pending component is provided.\n         *\n         * @link [API Docs](https://tanstack.com/router/latest/docs/framework/solid/api/router/RouterOptionsType#defaultpendingcomponent-property)\n         * @link [Guide](https://tanstack.com/router/latest/docs/framework/solid/guide/data-loading#showing-a-pending-component)\n         */\n        defaultPendingComponent?: RouteComponent;\n        /**\n         * The default `notFoundComponent` a route should use if no notFound component is provided.\n         *\n         * @default NotFound\n         * @link [API Docs](https://tanstack.com/router/latest/docs/framework/solid/api/router/RouterOptionsType#defaultnotfoundcomponent-property)\n         * @link [Guide](https://tanstack.com/router/latest/docs/framework/solid/guide/not-found-errors#default-router-wide-not-found-handling)\n         */\n        defaultNotFoundComponent?: RouteComponent;\n    }\n};\ndeclare const createRouter: CreateRouterFn;","originalLength":2813,"removedExports":["Router"],"renderedExports":["createRouter"],"renderedLength":1938},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/RouterProvider.d.ts":{"code":"declare class RouterProvider {\n    router: _angular_core.InputSignal<AnyRouter>;\n    renderer: {\n        clear: () => void;\n        render: ({ component, providers, key, inputs }: {\n            key?: string;\n            component: _tanstack_angular_router.RouteComponent | null | undefined;\n            inputs?: Record<string, () => unknown>;\n            providers?: _angular_core.Provider[];\n        }) => void;\n    };\n    render: _angular_core.EffectRef;\n    static ɵfac: _angular_core.ɵɵFactoryDeclaration<RouterProvider, never>;\n    static ɵcmp: _angular_core.ɵɵComponentDeclaration<RouterProvider, \"router-provider\", never, { \"router\": { \"alias\": \"router\"; \"required\": true; \"isSignal\": true; }; }, {}, never, never, true, never>;\n}","originalLength":895,"removedExports":[],"renderedExports":["RouterProvider"],"renderedLength":737},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/Match.d.ts":{"code":"declare class RouteMatch {\n    matchId: _angular_core.InputSignal<string>;\n    router: AnyRouter;\n    matchData: Signal<{\n        key: string | undefined;\n        route: AnyRoute;\n        match: _tanstack_router_core.RouteMatch<any, any, any, any, any, any, any>;\n        parentRouteId: any;\n    } | null>;\n    isFistRouteInRouteTree: Signal<boolean>;\n    resolvedNoSsr: Signal<boolean>;\n    shouldClientOnly: Signal<boolean>;\n    rendering: {\n        clear: () => void;\n        render: ({ component, providers, key, inputs }: {\n            key?: string;\n            component: RouteComponent | null | undefined;\n            inputs?: Record<string, () => unknown>;\n            providers?: Provider[];\n        }) => void;\n    };\n    render: _angular_core.EffectRef;\n    static ɵfac: _angular_core.ɵɵFactoryDeclaration<RouteMatch, never>;\n    static ɵcmp: _angular_core.ɵɵComponentDeclaration<RouteMatch, \"router-match\", never, { \"matchId\": { \"alias\": \"matchId\"; \"required\": true; \"isSignal\": true; }; }, {}, never, never, true, never>;\n}\ndeclare class Outlet {\n    router: AnyRouter;\n    matchId: Signal<string | undefined>;\n    routeId: Signal<string>;\n    route: Signal<AnyRoute>;\n    parentGlobalNotFound: Signal<boolean | undefined>;\n    childMatchId: Signal<string | null>;\n    rendering: {\n        clear: () => void;\n        render: ({ component, providers, key, inputs }: {\n            key?: string;\n            component: RouteComponent | null | undefined;\n            inputs?: Record<string, () => unknown>;\n            providers?: Provider[];\n        }) => void;\n    };\n    render: _angular_core.EffectRef;\n    static ɵfac: _angular_core.ɵɵFactoryDeclaration<Outlet, never>;\n    static ɵcmp: _angular_core.ɵɵComponentDeclaration<Outlet, \"outlet\", never, {}, {}, never, never, true, never>;\n}","originalLength":2036,"removedExports":[],"renderedExports":["RouteMatch","Outlet"],"renderedLength":1800},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/Macthes.d.ts":{"code":"declare class Matches {\n    private matchId;\n    renderer: {\n        clear: () => void;\n        render: ({ component, providers, key, inputs }: {\n            key?: string;\n            component: _tanstack_angular_router.RouteComponent | null | undefined;\n            inputs?: Record<string, () => unknown>;\n            providers?: _angular_core.Provider[];\n        }) => void;\n    };\n    transitioner: void;\n    render: _angular_core.EffectRef;\n    static ɵfac: _angular_core.ɵɵFactoryDeclaration<Matches, never>;\n    static ɵcmp: _angular_core.ɵɵComponentDeclaration<Matches, \"router-matches\", never, {}, {}, never, never, true, never>;\n}","originalLength":729,"removedExports":[],"renderedExports":["Matches"],"renderedLength":639},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/injectRouter.d.ts":{"code":"declare function injectRouter<TRouter extends AnyRouter = RegisteredRouter>(opts?: {\n    warn?: boolean;\n}): TRouter;\ntype InjectRouterResult<TRouter extends AnyRouter = RegisteredRouter> = TRouter;","originalLength":329,"removedExports":[],"renderedExports":["injectRouter","InjectRouterResult"],"renderedLength":198},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/injectRouterState.d.ts":{"code":"type InjectRouterStateOptions<TRouter extends AnyRouter, TSelected> = {\n    router?: TRouter;\n    select?: (state: RouterState<TRouter['routeTree']>) => TSelected;\n};\ntype InjectRouterStateResult<TRouter extends AnyRouter, TSelected> = unknown extends TSelected ? RouterState<TRouter['routeTree']> : TSelected;\ndeclare function injectRouterState<TRouter extends AnyRouter = RegisteredRouter, TSelected = unknown>(opts?: InjectRouterStateOptions<TRouter, TSelected>): Signal<InjectRouterStateResult<TRouter, TSelected>>;","originalLength":715,"removedExports":[],"renderedExports":["InjectRouterStateOptions","InjectRouterStateResult","injectRouterState"],"renderedLength":519},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/injectNavigate.d.ts":{"code":"declare function injectNavigate<TRouter extends AnyRouter = RegisteredRouter, TDefaultFrom extends string = string>(_defaultOpts?: {\n    from?: FromPathOption<TRouter, TDefaultFrom>;\n}): UseNavigateResult<TDefaultFrom>;\ntype InjectNavigateResult<TRouter extends AnyRouter = RegisteredRouter, TDefaultFrom extends string = string> = UseNavigateResult<TDefaultFrom>;","originalLength":532,"removedExports":[],"renderedExports":["injectNavigate","InjectNavigateResult"],"renderedLength":364},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/injectLocationResult.d.ts":{"code":"interface InjectLocationOptions<TRouter extends AnyRouter, TSelected> {\n    select?: (location: RouterState<TRouter['routeTree']>['location']) => TSelected;\n}\ntype InjectLocationResult<TRouter extends AnyRouter, TSelected> = unknown extends TSelected ? RouterState<TRouter['routeTree']>['location'] : TSelected;\ndeclare function injectLocation<TRouter extends AnyRouter = RegisteredRouter, TSelected = unknown>(opts: InjectLocationOptions<TRouter, TSelected>): Signal<InjectLocationResult<TRouter, TSelected>>;","originalLength":704,"removedExports":[],"renderedExports":["InjectLocationOptions","InjectLocationResult","injectLocation"],"renderedLength":510},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/injectBlocker.d.ts":{"code":"interface ShouldBlockFnLocation<out TRouteId, out TFullPath, out TAllParams, out TFullSearchSchema> {\n    routeId: TRouteId;\n    fullPath: TFullPath;\n    pathname: string;\n    params: TAllParams;\n    search: TFullSearchSchema;\n}\ntype MakeShouldBlockFnLocationUnion<TRouter extends AnyRouter = RegisteredRouter, TRoute extends AnyRoute = ParseRoute<TRouter['routeTree']>> = TRoute extends any ? ShouldBlockFnLocation<TRoute['id'], TRoute['fullPath'], TRoute['types']['allParams'], TRoute['types']['fullSearchSchema']> : never;\ntype BlockerResolver<TRouter extends AnyRouter = RegisteredRouter> = {\n    status: 'blocked';\n    current: MakeShouldBlockFnLocationUnion<TRouter>;\n    next: MakeShouldBlockFnLocationUnion<TRouter>;\n    action: HistoryAction;\n    proceed: () => void;\n    reset: () => void;\n} | {\n    status: 'idle';\n    current: undefined;\n    next: undefined;\n    action: undefined;\n    proceed: undefined;\n    reset: undefined;\n};\ntype ShouldBlockFnArgs<TRouter extends AnyRouter = RegisteredRouter> = {\n    current: MakeShouldBlockFnLocationUnion<TRouter>;\n    next: MakeShouldBlockFnLocationUnion<TRouter>;\n    action: HistoryAction;\n};\ntype ShouldBlockFn<TRouter extends AnyRouter = RegisteredRouter> = (args: ShouldBlockFnArgs<TRouter>) => boolean | Promise<boolean>;\ntype UseBlockerOpts<TRouter extends AnyRouter = RegisteredRouter, TWithResolver extends boolean = boolean> = {\n    shouldBlockFn: ShouldBlockFn<TRouter>;\n    enableBeforeUnload?: boolean | (() => boolean);\n    disabled?: boolean;\n    withResolver?: TWithResolver;\n};\ntype InjectBlockerOpts<TRouter extends AnyRouter = RegisteredRouter, TWithResolver extends boolean = boolean> = {\n    shouldBlockFn: ShouldBlockFn<TRouter>;\n    enableBeforeUnload?: boolean | (() => boolean);\n    disabled?: boolean;\n    withResolver?: TWithResolver;\n};\ndeclare function injectBlocker<TRouter extends AnyRouter = RegisteredRouter, TWithResolver extends boolean = boolean>(opts: InjectBlockerOpts<TRouter, TWithResolver>): TWithResolver extends true ? Signal<BlockerResolver<TRouter>> : void;","originalLength":2328,"removedExports":[],"renderedExports":["ShouldBlockFn","UseBlockerOpts","InjectBlockerOpts","injectBlocker"],"renderedLength":2058},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/injectCanGoBack.d.ts":{"code":"declare function injectCanGoBack(): _angular_core.Signal<boolean>;","originalLength":129,"removedExports":[],"renderedExports":["injectCanGoBack"],"renderedLength":66},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/Link.d.ts":{"code":"type LinkInputOptions<TRouter extends AnyRouter = RegisteredRouter, TFrom extends RoutePaths<TRouter['routeTree']> | string = string, TTo extends string | undefined = '.', TMaskFrom extends RoutePaths<TRouter['routeTree']> | string = TFrom, TMaskTo extends string = '.'> = LinkOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo> & {};","originalLength":3568,"removedExports":["RouterLink"],"renderedExports":["LinkInputOptions"],"renderedLength":331},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/injectIntersectionObserver.d.ts":{"code":"declare function injectIntersectionObserver(callback: (entry: IntersectionObserverEntry | undefined) => void, intersectionObserverOptions: IntersectionObserverInit, disabled: () => boolean): void;","originalLength":260,"removedExports":[],"renderedExports":["injectIntersectionObserver"],"renderedLength":196},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/dynamicRenderer.d.ts":{"code":"type RenderParams = {\n    key?: string;\n    component: RouteComponent | null | undefined;\n    inputs?: Record<string, () => unknown>;\n    providers?: Provider[];\n};\ndeclare function injectDynamicRenderer(): {\n    clear: () => void;\n    render: ({ component, providers, key, inputs }: RenderParams) => void;\n};","originalLength":457,"removedExports":[],"renderedExports":["injectDynamicRenderer"],"renderedLength":309},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/routerInjectionToken.d.ts":{"code":"declare global {\n    interface Window {\n        __TSR_ROUTER_INJECTION_KEY__?: InjectionToken<AnyRouter>;\n    }\n};\ndeclare function getRouterInjectionKey(): InjectionToken<AnyRouter>;","originalLength":344,"removedExports":["global"],"renderedExports":["getRouterInjectionKey"],"renderedLength":183},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/matchInjectorToken.d.ts":{"code":"declare const MATCH_ID_INJECTOR_TOKEN: InjectionToken<Signal<string | undefined>>;","originalLength":194,"removedExports":[],"renderedExports":["MATCH_ID_INJECTOR_TOKEN"],"renderedLength":82},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-typings/tanstack-angular-router.d.ts":{"code":null,"originalLength":177,"removedExports":[],"renderedExports":[],"renderedLength":0}},"referencedFiles":[],"code":"import * as _tanstack_router_core from '@tanstack/router-core';\nimport { AnyRouter, RegisteredRouter, ResolveUseLoaderData, UseLoaderDataResult, StrictOrFrom, MakeRouteMatch, MakeRouteMatchUnion, ThrowConstraint, ThrowOrOptional, ResolveUseLoaderDeps, UseLoaderDepsResult, ResolveUseParams, UseParamsResult, ResolveUseSearch, UseSearchResult, UseRouteContextBaseOptions, UseRouteContextResult, UseRouteContextOptions, UseNavigateResult, RouteConstraints, AnyRoute, ResolveFullPath, ResolveId, ResolveParams, AnyContext, RouteOptions, BaseRoute, Route as Route$1, Register, RootRouteOptions, BaseRootRoute, RootRoute as RootRoute$1, RootRouteId, ToMaskOptions, RouterCore, RouteMask, ConstrainLiteral, RouteIds, BaseRouteApi, RouteTypesById, NotFoundError, CreateRouterFn, RouterState, FromPathOption, ParseRoute, RoutePaths, LinkOptions } from '@tanstack/router-core';\nexport { AnyRouter, LinkOptions, NavigateOptions, RegisteredRouter, RootRouteOptions, RouteOptions, RouterState } from '@tanstack/router-core';\nimport * as _angular_core from '@angular/core';\nimport { Signal, Type, Provider, InjectionToken } from '@angular/core';\nimport * as _tanstack_angular_router from '@tanstack/angular-router';\nimport { HistoryAction } from '@tanstack/history';\n\ninterface InjectLoaderDataBaseOptions<TRouter extends AnyRouter, TFrom, TStrict extends boolean, TSelected> {\n    select?: (match: ResolveUseLoaderData<TRouter, TFrom, TStrict>) => TSelected;\n}\ntype InjectLoaderDataOptions<TRouter extends AnyRouter, TFrom extends string | undefined, TStrict extends boolean, TSelected> = StrictOrFrom<TRouter, TFrom, TStrict> & InjectLoaderDataBaseOptions<TRouter, TFrom, TStrict, TSelected>;\ntype InjectLoaderDataRoute<out TFrom> = <TRouter extends AnyRouter = RegisteredRouter, TSelected = unknown>(opts?: InjectLoaderDataBaseOptions<TRouter, TFrom, true, TSelected>) => Signal<UseLoaderDataResult<TRouter, TFrom, true, TSelected>>;\ndeclare function injectLoaderData<TRouter extends AnyRouter = RegisteredRouter, const TFrom extends string | undefined = undefined, TStrict extends boolean = true, TSelected = unknown>(opts: InjectLoaderDataOptions<TRouter, TFrom, TStrict, TSelected>): Signal<UseLoaderDataResult<TRouter, TFrom, TStrict, TSelected>>;\n\ninterface InjectMatchBaseOptions<TRouter extends AnyRouter, TFrom, TStrict extends boolean, TThrow extends boolean, TSelected> {\n    select?: (match: MakeRouteMatch<TRouter['routeTree'], TFrom, TStrict>) => TSelected;\n    shouldThrow?: TThrow;\n}\ntype InjectMatchOptions<TRouter extends AnyRouter, TFrom, TStrict extends boolean, TThrow extends boolean, TSelected> = StrictOrFrom<TRouter, TFrom, TStrict> & InjectMatchBaseOptions<TRouter, TFrom, TStrict, TThrow, TSelected>;\ntype InjectMatchResult<TRouter extends AnyRouter, TFrom, TStrict extends boolean, TSelected> = unknown extends TSelected ? TStrict extends true ? MakeRouteMatch<TRouter['routeTree'], TFrom, TStrict> : MakeRouteMatchUnion<TRouter> : TSelected;\ntype InjectMatchRoute<out TFrom> = <TRouter extends AnyRouter = RegisteredRouter, TSelected = unknown>(opts?: InjectMatchBaseOptions<TRouter, TFrom, true, true, TSelected>) => Signal<InjectMatchResult<TRouter, TFrom, true, TSelected>>;\ndeclare function injectMatch<TRouter extends AnyRouter = RegisteredRouter, const TFrom extends string | undefined = undefined, TStrict extends boolean = true, TThrow extends boolean = true, TSelected = unknown>(opts: InjectMatchOptions<TRouter, TFrom, TStrict, ThrowConstraint<TStrict, TThrow>, TSelected>): Signal<ThrowOrOptional<InjectMatchResult<TRouter, TFrom, TStrict, TSelected>, TThrow>>;\n\ninterface InjectLoaderDepsBaseOptions<TRouter extends AnyRouter, TFrom, TSelected> {\n    select?: (deps: ResolveUseLoaderDeps<TRouter, TFrom>) => TSelected;\n}\ntype InjectLoaderDepsOptions<TRouter extends AnyRouter, TFrom extends string | undefined, TSelected> = StrictOrFrom<TRouter, TFrom> & InjectLoaderDepsBaseOptions<TRouter, TFrom, TSelected>;\ntype InjectLoaderDepsRoute<out TFrom> = <TRouter extends AnyRouter = RegisteredRouter, TSelected = unknown>(opts?: InjectLoaderDepsBaseOptions<TRouter, TFrom, TSelected>) => Signal<UseLoaderDepsResult<TRouter, TFrom, TSelected>>;\ndeclare function injectLoaderDeps<TRouter extends AnyRouter = RegisteredRouter, const TFrom extends string | undefined = undefined, TSelected = unknown>(opts: InjectLoaderDepsOptions<TRouter, TFrom, TSelected>): Signal<UseLoaderDepsResult<TRouter, TFrom, TSelected>>;\n\ninterface InjectParamsBaseOptions<TRouter extends AnyRouter, TFrom, TStrict extends boolean, TThrow extends boolean, TSelected> {\n    select?: (params: ResolveUseParams<TRouter, TFrom, TStrict>) => TSelected;\n    shouldThrow?: TThrow;\n}\ntype InjectParamsOptions<TRouter extends AnyRouter, TFrom extends string | undefined, TStrict extends boolean, TThrow extends boolean, TSelected> = StrictOrFrom<TRouter, TFrom, TStrict> & InjectParamsBaseOptions<TRouter, TFrom, TStrict, TThrow, TSelected>;\ntype InjectParamsRoute<out TFrom> = <TRouter extends AnyRouter = RegisteredRouter, TSelected = unknown>(opts?: InjectParamsBaseOptions<TRouter, TFrom, true, true, TSelected>) => Signal<UseParamsResult<TRouter, TFrom, true, TSelected>>;\ndeclare function injectParams<TRouter extends AnyRouter = RegisteredRouter, const TFrom extends string | undefined = undefined, TStrict extends boolean = true, TThrow extends boolean = true, TSelected = unknown>(opts: InjectParamsOptions<TRouter, TFrom, TStrict, ThrowConstraint<TStrict, TThrow>, TSelected>): Signal<ThrowOrOptional<UseParamsResult<TRouter, TFrom, true, TSelected>, TThrow>>;\n\ninterface InjectSearchBaseOptions<TRouter extends AnyRouter, TFrom, TStrict extends boolean, TThrow extends boolean, TSelected> {\n    select?: (state: ResolveUseSearch<TRouter, TFrom, TStrict>) => TSelected;\n    shouldThrow?: TThrow;\n}\ntype InjectSearchOptions<TRouter extends AnyRouter, TFrom, TStrict extends boolean, TThrow extends boolean, TSelected> = StrictOrFrom<TRouter, TFrom, TStrict> & InjectSearchBaseOptions<TRouter, TFrom, TStrict, TThrow, TSelected>;\ntype InjectSearchRoute<out TFrom> = <TRouter extends AnyRouter = RegisteredRouter, TSelected = unknown>(opts?: InjectSearchBaseOptions<TRouter, TFrom, true, true, TSelected>) => Signal<UseSearchResult<TRouter, TFrom, true, TSelected>>;\ndeclare function injectSearch<TRouter extends AnyRouter = RegisteredRouter, const TFrom extends string | undefined = undefined, TStrict extends boolean = true, TThrow extends boolean = true, TSelected = unknown>(opts: InjectSearchOptions<TRouter, TFrom, TStrict, ThrowConstraint<TStrict, TThrow>, TSelected>): Signal<ThrowOrOptional<UseSearchResult<TRouter, TFrom, TStrict, TSelected>, TThrow>>;\n\ntype InjectRouteContextRoute<out TFrom> = <TRouter extends AnyRouter = RegisteredRouter, TSelected = unknown>(opts?: UseRouteContextBaseOptions<TRouter, TFrom, true, TSelected>) => Signal<UseRouteContextResult<TRouter, TFrom, true, TSelected>>;\ndeclare function injectRouterContext<TRouter extends AnyRouter = RegisteredRouter, const TFrom extends string | undefined = undefined, TStrict extends boolean = true, TSelected = unknown>(opts: UseRouteContextOptions<TRouter, TFrom, TStrict, TSelected>): Signal<UseRouteContextResult<TRouter, TFrom, TStrict, TSelected>>;\n\ndeclare module '@tanstack/router-core' {\n    interface UpdatableRouteOptionsExtensions {\n        component?: RouteComponent;\n        errorComponent?: false | null | undefined | ErrorRouteComponent;\n        notFoundComponent?: NotFoundRouteComponent;\n        pendingComponent?: RouteComponent;\n    }\n    interface RootRouteOptionsExtensions {\n        shellComponent?: Type<{\n            children: any;\n        }>;\n    }\n    interface RouteExtensions<in out TId extends string, in out TFullPath extends string> {\n        injectMatch: InjectMatchRoute<TId>;\n        injectRouteContext: InjectRouteContextRoute<TId>;\n        injectSearch: InjectSearchRoute<TId>;\n        injectParams: InjectParamsRoute<TId>;\n        injectLoaderDeps: InjectLoaderDepsRoute<TId>;\n        injectLoaderData: InjectLoaderDataRoute<TId>;\n        injectNavigate: () => UseNavigateResult<TFullPath>;\n    }\n}\ndeclare function getRouteApi<const TId, TRouter extends AnyRouter = RegisteredRouter>(id: ConstrainLiteral<TId, RouteIds<TRouter['routeTree']>>): RouteApi<TId, TRouter>;\ndeclare class RouteApi<TId, TRouter extends AnyRouter = RegisteredRouter> extends BaseRouteApi<TId, TRouter> {\n    /**\n     * @deprecated Use the `getRouteApi` function instead.\n     */\n    constructor({ id }: {\n        id: TId;\n    });\n    injectMatch: InjectMatchRoute<TId>;\n    injectRouteContext: InjectRouteContextRoute<TId>;\n    injectSearch: InjectSearchRoute<TId>;\n    injectParams: InjectParamsRoute<TId>;\n    injectLoaderDeps: InjectLoaderDepsRoute<TId>;\n    injectLoaderData: InjectLoaderDataRoute<TId>;\n    injectNavigate: () => UseNavigateResult<RouteTypesById<TRouter, TId>[\"fullPath\"]>;\n    notFound: (opts?: NotFoundError) => NotFoundError;\n}\ndeclare class Route<in out TRegister = unknown, in out TParentRoute extends RouteConstraints['TParentRoute'] = AnyRoute, in out TPath extends RouteConstraints['TPath'] = '/', in out TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<TParentRoute, TPath>, in out TCustomId extends RouteConstraints['TCustomId'] = string, in out TId extends RouteConstraints['TId'] = ResolveId<TParentRoute, TCustomId, TPath>, in out TSearchValidator = undefined, in out TParams = ResolveParams<TPath>, in out TRouterContext = AnyContext, in out TRouteContextFn = AnyContext, in out TBeforeLoadFn = AnyContext, in out TLoaderDeps extends Record<string, any> = {}, in out TLoaderFn = undefined, in out TChildren = unknown, in out TFileRouteTypes = unknown, in out TSSR = unknown, in out TMiddlewares = unknown, in out THandlers = undefined> extends BaseRoute<TRegister, TParentRoute, TPath, TFullPath, TCustomId, TId, TSearchValidator, TParams, TRouterContext, TRouteContextFn, TBeforeLoadFn, TLoaderDeps, TLoaderFn, TChildren, TFileRouteTypes, TSSR, TMiddlewares, THandlers> implements Route$1<TRegister, TParentRoute, TPath, TFullPath, TCustomId, TId, TSearchValidator, TParams, TRouterContext, TRouteContextFn, TBeforeLoadFn, TLoaderDeps, TLoaderFn, TChildren, TFileRouteTypes, TSSR, TMiddlewares, THandlers> {\n    /**\n     * @deprecated Use the `createRoute` function instead.\n     */\n    constructor(options?: RouteOptions<TRegister, TParentRoute, TId, TCustomId, TFullPath, TPath, TSearchValidator, TParams, TLoaderDeps, TLoaderFn, TRouterContext, TRouteContextFn, TBeforeLoadFn, TSSR, TMiddlewares, THandlers>);\n    injectMatch: InjectMatchRoute<TId>;\n    injectRouteContext: InjectRouteContextRoute<TId>;\n    injectSearch: InjectSearchRoute<TId>;\n    injectParams: InjectParamsRoute<TId>;\n    injectLoaderDeps: InjectLoaderDepsRoute<TId>;\n    injectLoaderData: InjectLoaderDataRoute<TId>;\n    injectNavigate: () => UseNavigateResult<TFullPath>;\n}\ndeclare function createRoute<TRegister = unknown, TParentRoute extends RouteConstraints['TParentRoute'] = AnyRoute, TPath extends RouteConstraints['TPath'] = '/', TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<TParentRoute, TPath>, TCustomId extends RouteConstraints['TCustomId'] = string, TId extends RouteConstraints['TId'] = ResolveId<TParentRoute, TCustomId, TPath>, TSearchValidator = undefined, TParams = ResolveParams<TPath>, TRouteContextFn = AnyContext, TBeforeLoadFn = AnyContext, TLoaderDeps extends Record<string, any> = {}, TLoaderFn = undefined, TChildren = unknown, TSSR = unknown, THandlers = undefined>(options: RouteOptions<TRegister, TParentRoute, TId, TCustomId, TFullPath, TPath, TSearchValidator, TParams, TLoaderDeps, TLoaderFn, AnyContext, TRouteContextFn, TBeforeLoadFn, TSSR, THandlers>): Route<TRegister, TParentRoute, TPath, TFullPath, TCustomId, TId, TSearchValidator, TParams, AnyContext, TRouteContextFn, TBeforeLoadFn, TLoaderDeps, TLoaderFn, TChildren, unknown, TSSR, THandlers>;\ntype AnyRootRoute = RootRoute<any, any, any, any, any, any, any, any, any, any>;\ndeclare function createRootRouteWithContext<TRouterContext extends {}>(): <TRegister = Register, TRouteContextFn = AnyContext, TBeforeLoadFn = AnyContext, TSearchValidator = undefined, TLoaderDeps extends Record<string, any> = {}, TLoaderFn = undefined, TSSR = unknown, THandlers = undefined>(options?: RootRouteOptions<TRegister, TSearchValidator, TRouterContext, TRouteContextFn, TBeforeLoadFn, TLoaderDeps, TLoaderFn, TSSR, THandlers>) => RootRoute<TRegister, TSearchValidator, TRouterContext, TRouteContextFn, TBeforeLoadFn, TLoaderDeps, TLoaderFn, unknown, unknown, TSSR, THandlers>;\n/**\n * @deprecated Use the `createRootRouteWithContext` function instead.\n */\ndeclare const rootRouteWithContext: typeof createRootRouteWithContext;\ndeclare class RootRoute<in out TRegister = Register, in out TSearchValidator = undefined, in out TRouterContext = {}, in out TRouteContextFn = AnyContext, in out TBeforeLoadFn = AnyContext, in out TLoaderDeps extends Record<string, any> = {}, in out TLoaderFn = undefined, in out TChildren = unknown, in out TFileRouteTypes = unknown, in out TSSR = unknown, in out THandlers = undefined> extends BaseRootRoute<TRegister, TSearchValidator, TRouterContext, TRouteContextFn, TBeforeLoadFn, TLoaderDeps, TLoaderFn, TChildren, TFileRouteTypes, TSSR, THandlers> implements RootRoute$1<TRegister, TSearchValidator, TRouterContext, TRouteContextFn, TBeforeLoadFn, TLoaderDeps, TLoaderFn, TChildren, TFileRouteTypes, TSSR, THandlers> {\n    /**\n     * @deprecated `RootRoute` is now an internal implementation detail. Use `createRootRoute()` instead.\n     */\n    constructor(options?: RootRouteOptions<TRegister, TSearchValidator, TRouterContext, TRouteContextFn, TBeforeLoadFn, TLoaderDeps, TLoaderFn, TSSR, THandlers>);\n    injectMatch: InjectMatchRoute<RootRouteId>;\n    injectRouteContext: InjectRouteContextRoute<RootRouteId>;\n    injectSearch: InjectSearchRoute<RootRouteId>;\n    injectParams: InjectParamsRoute<RootRouteId>;\n    injectLoaderDeps: InjectLoaderDepsRoute<RootRouteId>;\n    injectLoaderData: InjectLoaderDataRoute<RootRouteId>;\n    injectNavigate: () => UseNavigateResult<\"/\">;\n}\ndeclare function createRouteMask<TRouteTree extends AnyRoute, TFrom extends string, TTo extends string>(opts: {\n    routeTree: TRouteTree;\n} & ToMaskOptions<RouterCore<TRouteTree, 'never', false>, TFrom, TTo>): RouteMask<TRouteTree>;\ntype RouteComponent<TComponent = unknown> = Type<TComponent>;\ntype ErrorRouteComponent = Type<unknown>;\ntype NotFoundRouteComponent = Type<unknown>;\ndeclare class NotFoundRoute<TRegister, TParentRoute extends AnyRootRoute, TRouterContext = AnyContext, TRouteContextFn = AnyContext, TBeforeLoadFn = AnyContext, TSearchValidator = undefined, TLoaderDeps extends Record<string, any> = {}, TLoaderFn = undefined, TChildren = unknown, TSSR = unknown, THandlers = undefined> extends Route<TRegister, TParentRoute, '/404', '/404', '404', '404', TSearchValidator, {}, TRouterContext, TRouteContextFn, TBeforeLoadFn, TLoaderDeps, TLoaderFn, TChildren, TSSR, THandlers> {\n    constructor(options: Omit<RouteOptions<TRegister, TParentRoute, string, string, string, string, TSearchValidator, {}, TLoaderDeps, TLoaderFn, TRouterContext, TRouteContextFn, TBeforeLoadFn, TSSR, THandlers>, 'caseSensitive' | 'parseParams' | 'stringifyParams' | 'path' | 'id' | 'params'>);\n}\ndeclare function createRootRoute<TRegister = Register, TSearchValidator = undefined, TRouterContext = {}, TRouteContextFn = AnyContext, TBeforeLoadFn = AnyContext, TLoaderDeps extends Record<string, any> = {}, TLoaderFn = undefined, TSSR = unknown, THandlers = undefined>(options?: RootRouteOptions<TRegister, TSearchValidator, TRouterContext, TRouteContextFn, TBeforeLoadFn, TLoaderDeps, TLoaderFn, TSSR, THandlers>): RootRoute<TRegister, TSearchValidator, TRouterContext, TRouteContextFn, TBeforeLoadFn, TLoaderDeps, TLoaderFn, unknown, unknown, TSSR, THandlers>;\n\ndeclare module '@tanstack/router-core' {\n    interface RouterOptionsExtensions {\n        /**\n         * The default `component` a route should use if no component is provided.\n         *\n         * @default Outlet\n         * @link [API Docs](https://tanstack.com/router/latest/docs/framework/solid/api/router/RouterOptionsType#defaultcomponent-property)\n         */\n        defaultComponent?: RouteComponent;\n        /**\n         * The default `errorComponent` a route should use if no error component is provided.\n         *\n         * @default ErrorComponent\n         * @link [API Docs](https://tanstack.com/router/latest/docs/framework/solid/api/router/RouterOptionsType#defaulterrorcomponent-property)\n         * @link [Guide](https://tanstack.com/router/latest/docs/framework/solid/guide/data-loading#handling-errors-with-routeoptionserrorcomponent)\n         */\n        defaultErrorComponent?: ErrorRouteComponent;\n        /**\n         * The default `pendingComponent` a route should use if no pending component is provided.\n         *\n         * @link [API Docs](https://tanstack.com/router/latest/docs/framework/solid/api/router/RouterOptionsType#defaultpendingcomponent-property)\n         * @link [Guide](https://tanstack.com/router/latest/docs/framework/solid/guide/data-loading#showing-a-pending-component)\n         */\n        defaultPendingComponent?: RouteComponent;\n        /**\n         * The default `notFoundComponent` a route should use if no notFound component is provided.\n         *\n         * @default NotFound\n         * @link [API Docs](https://tanstack.com/router/latest/docs/framework/solid/api/router/RouterOptionsType#defaultnotfoundcomponent-property)\n         * @link [Guide](https://tanstack.com/router/latest/docs/framework/solid/guide/not-found-errors#default-router-wide-not-found-handling)\n         */\n        defaultNotFoundComponent?: RouteComponent;\n    }\n}\ndeclare const createRouter: CreateRouterFn;\n\ndeclare class RouterProvider {\n    router: _angular_core.InputSignal<AnyRouter>;\n    renderer: {\n        clear: () => void;\n        render: ({ component, providers, key, inputs }: {\n            key?: string;\n            component: _tanstack_angular_router.RouteComponent | null | undefined;\n            inputs?: Record<string, () => unknown>;\n            providers?: _angular_core.Provider[];\n        }) => void;\n    };\n    render: _angular_core.EffectRef;\n    static ɵfac: _angular_core.ɵɵFactoryDeclaration<RouterProvider, never>;\n    static ɵcmp: _angular_core.ɵɵComponentDeclaration<RouterProvider, \"router-provider\", never, { \"router\": { \"alias\": \"router\"; \"required\": true; \"isSignal\": true; }; }, {}, never, never, true, never>;\n}\n\ndeclare class RouteMatch {\n    matchId: _angular_core.InputSignal<string>;\n    router: AnyRouter;\n    matchData: Signal<{\n        key: string | undefined;\n        route: AnyRoute;\n        match: _tanstack_router_core.RouteMatch<any, any, any, any, any, any, any>;\n        parentRouteId: any;\n    } | null>;\n    isFistRouteInRouteTree: Signal<boolean>;\n    resolvedNoSsr: Signal<boolean>;\n    shouldClientOnly: Signal<boolean>;\n    rendering: {\n        clear: () => void;\n        render: ({ component, providers, key, inputs }: {\n            key?: string;\n            component: RouteComponent | null | undefined;\n            inputs?: Record<string, () => unknown>;\n            providers?: Provider[];\n        }) => void;\n    };\n    render: _angular_core.EffectRef;\n    static ɵfac: _angular_core.ɵɵFactoryDeclaration<RouteMatch, never>;\n    static ɵcmp: _angular_core.ɵɵComponentDeclaration<RouteMatch, \"router-match\", never, { \"matchId\": { \"alias\": \"matchId\"; \"required\": true; \"isSignal\": true; }; }, {}, never, never, true, never>;\n}\ndeclare class Outlet {\n    router: AnyRouter;\n    matchId: Signal<string | undefined>;\n    routeId: Signal<string>;\n    route: Signal<AnyRoute>;\n    parentGlobalNotFound: Signal<boolean | undefined>;\n    childMatchId: Signal<string | null>;\n    rendering: {\n        clear: () => void;\n        render: ({ component, providers, key, inputs }: {\n            key?: string;\n            component: RouteComponent | null | undefined;\n            inputs?: Record<string, () => unknown>;\n            providers?: Provider[];\n        }) => void;\n    };\n    render: _angular_core.EffectRef;\n    static ɵfac: _angular_core.ɵɵFactoryDeclaration<Outlet, never>;\n    static ɵcmp: _angular_core.ɵɵComponentDeclaration<Outlet, \"outlet\", never, {}, {}, never, never, true, never>;\n}\n\ndeclare class Matches {\n    private matchId;\n    renderer: {\n        clear: () => void;\n        render: ({ component, providers, key, inputs }: {\n            key?: string;\n            component: _tanstack_angular_router.RouteComponent | null | undefined;\n            inputs?: Record<string, () => unknown>;\n            providers?: _angular_core.Provider[];\n        }) => void;\n    };\n    transitioner: void;\n    render: _angular_core.EffectRef;\n    static ɵfac: _angular_core.ɵɵFactoryDeclaration<Matches, never>;\n    static ɵcmp: _angular_core.ɵɵComponentDeclaration<Matches, \"router-matches\", never, {}, {}, never, never, true, never>;\n}\n\ndeclare function injectRouter<TRouter extends AnyRouter = RegisteredRouter>(opts?: {\n    warn?: boolean;\n}): TRouter;\ntype InjectRouterResult<TRouter extends AnyRouter = RegisteredRouter> = TRouter;\n\ntype InjectRouterStateOptions<TRouter extends AnyRouter, TSelected> = {\n    router?: TRouter;\n    select?: (state: RouterState<TRouter['routeTree']>) => TSelected;\n};\ntype InjectRouterStateResult<TRouter extends AnyRouter, TSelected> = unknown extends TSelected ? RouterState<TRouter['routeTree']> : TSelected;\ndeclare function injectRouterState<TRouter extends AnyRouter = RegisteredRouter, TSelected = unknown>(opts?: InjectRouterStateOptions<TRouter, TSelected>): Signal<InjectRouterStateResult<TRouter, TSelected>>;\n\ndeclare function injectNavigate<TRouter extends AnyRouter = RegisteredRouter, TDefaultFrom extends string = string>(_defaultOpts?: {\n    from?: FromPathOption<TRouter, TDefaultFrom>;\n}): UseNavigateResult<TDefaultFrom>;\ntype InjectNavigateResult<TRouter extends AnyRouter = RegisteredRouter, TDefaultFrom extends string = string> = UseNavigateResult<TDefaultFrom>;\n\ninterface InjectLocationOptions<TRouter extends AnyRouter, TSelected> {\n    select?: (location: RouterState<TRouter['routeTree']>['location']) => TSelected;\n}\ntype InjectLocationResult<TRouter extends AnyRouter, TSelected> = unknown extends TSelected ? RouterState<TRouter['routeTree']>['location'] : TSelected;\ndeclare function injectLocation<TRouter extends AnyRouter = RegisteredRouter, TSelected = unknown>(opts: InjectLocationOptions<TRouter, TSelected>): Signal<InjectLocationResult<TRouter, TSelected>>;\n\ninterface ShouldBlockFnLocation<out TRouteId, out TFullPath, out TAllParams, out TFullSearchSchema> {\n    routeId: TRouteId;\n    fullPath: TFullPath;\n    pathname: string;\n    params: TAllParams;\n    search: TFullSearchSchema;\n}\ntype MakeShouldBlockFnLocationUnion<TRouter extends AnyRouter = RegisteredRouter, TRoute extends AnyRoute = ParseRoute<TRouter['routeTree']>> = TRoute extends any ? ShouldBlockFnLocation<TRoute['id'], TRoute['fullPath'], TRoute['types']['allParams'], TRoute['types']['fullSearchSchema']> : never;\ntype BlockerResolver<TRouter extends AnyRouter = RegisteredRouter> = {\n    status: 'blocked';\n    current: MakeShouldBlockFnLocationUnion<TRouter>;\n    next: MakeShouldBlockFnLocationUnion<TRouter>;\n    action: HistoryAction;\n    proceed: () => void;\n    reset: () => void;\n} | {\n    status: 'idle';\n    current: undefined;\n    next: undefined;\n    action: undefined;\n    proceed: undefined;\n    reset: undefined;\n};\ntype ShouldBlockFnArgs<TRouter extends AnyRouter = RegisteredRouter> = {\n    current: MakeShouldBlockFnLocationUnion<TRouter>;\n    next: MakeShouldBlockFnLocationUnion<TRouter>;\n    action: HistoryAction;\n};\ntype ShouldBlockFn<TRouter extends AnyRouter = RegisteredRouter> = (args: ShouldBlockFnArgs<TRouter>) => boolean | Promise<boolean>;\ntype UseBlockerOpts<TRouter extends AnyRouter = RegisteredRouter, TWithResolver extends boolean = boolean> = {\n    shouldBlockFn: ShouldBlockFn<TRouter>;\n    enableBeforeUnload?: boolean | (() => boolean);\n    disabled?: boolean;\n    withResolver?: TWithResolver;\n};\ntype InjectBlockerOpts<TRouter extends AnyRouter = RegisteredRouter, TWithResolver extends boolean = boolean> = {\n    shouldBlockFn: ShouldBlockFn<TRouter>;\n    enableBeforeUnload?: boolean | (() => boolean);\n    disabled?: boolean;\n    withResolver?: TWithResolver;\n};\ndeclare function injectBlocker<TRouter extends AnyRouter = RegisteredRouter, TWithResolver extends boolean = boolean>(opts: InjectBlockerOpts<TRouter, TWithResolver>): TWithResolver extends true ? Signal<BlockerResolver<TRouter>> : void;\n\ndeclare function injectCanGoBack(): _angular_core.Signal<boolean>;\n\ntype LinkInputOptions<TRouter extends AnyRouter = RegisteredRouter, TFrom extends RoutePaths<TRouter['routeTree']> | string = string, TTo extends string | undefined = '.', TMaskFrom extends RoutePaths<TRouter['routeTree']> | string = TFrom, TMaskTo extends string = '.'> = LinkOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo> & {};\n\ndeclare function injectIntersectionObserver(callback: (entry: IntersectionObserverEntry | undefined) => void, intersectionObserverOptions: IntersectionObserverInit, disabled: () => boolean): void;\n\ntype RenderParams = {\n    key?: string;\n    component: RouteComponent | null | undefined;\n    inputs?: Record<string, () => unknown>;\n    providers?: Provider[];\n};\ndeclare function injectDynamicRenderer(): {\n    clear: () => void;\n    render: ({ component, providers, key, inputs }: RenderParams) => void;\n};\n\ndeclare global {\n    interface Window {\n        __TSR_ROUTER_INJECTION_KEY__?: InjectionToken<AnyRouter>;\n    }\n}\ndeclare function getRouterInjectionKey(): InjectionToken<AnyRouter>;\n\ndeclare const MATCH_ID_INJECTOR_TOKEN: InjectionToken<Signal<string | undefined>>;\n\nexport { MATCH_ID_INJECTOR_TOKEN, Matches, NotFoundRoute, Outlet, RootRoute, Route, RouteApi, RouteMatch, RouterProvider, createRootRoute, createRootRouteWithContext, createRoute, createRouteMask, createRouter, getRouteApi, getRouterInjectionKey, injectBlocker, injectCanGoBack, injectDynamicRenderer, injectIntersectionObserver, injectLoaderData, injectLoaderDeps, injectLocation, injectMatch, injectNavigate, injectParams, injectRouter, injectRouterContext, injectRouterState, injectSearch, rootRouteWithContext };\nexport type { AnyRootRoute, ErrorRouteComponent, InjectBlockerOpts, InjectLoaderDataBaseOptions, InjectLoaderDataOptions, InjectLoaderDataRoute, InjectLoaderDepsBaseOptions, InjectLoaderDepsOptions, InjectLoaderDepsRoute, InjectLocationOptions, InjectLocationResult, InjectMatchBaseOptions, InjectMatchOptions, InjectMatchResult, InjectMatchRoute, InjectNavigateResult, InjectParamsBaseOptions, InjectParamsOptions, InjectParamsRoute, InjectRouteContextRoute, InjectRouterResult, InjectRouterStateOptions, InjectRouterStateResult, InjectSearchBaseOptions, InjectSearchOptions, InjectSearchRoute, LinkInputOptions, NotFoundRouteComponent, RouteComponent, ShouldBlockFn, UseBlockerOpts };\n//# sourceMappingURL=tanstack-angular-router.d.ts.map\n","map":null,"preliminaryFileName":"tanstack-angular-router.d.ts","sourcemapFileName":"tanstack-angular-router.d.ts.map"},{"fileName":"tanstack-angular-router.d.ts.map","names":[],"needsCodeReference":false,"originalFileName":null,"originalFileNames":[],"source":"{\"version\":3,\"file\":\"tanstack-angular-router.d.ts\",\"sources\":[\"../../src/injectLoaderData.ts\",\"../../src/injectMatch.ts\",\"../../src/injectLoaderDeps.ts\",\"../../src/injectParams.ts\",\"../../src/injectSearch.ts\",\"../../src/injectRouteContext.ts\",\"../../src/route.ts\",\"../../src/router.ts\",\"../../src/RouterProvider.ts\",\"../../src/Match.ts\",\"../../src/Macthes.ts\",\"../../src/injectRouter.ts\",\"../../src/injectRouterState.ts\",\"../../src/injectNavigate.ts\",\"../../src/injectLocationResult.ts\",\"../../src/injectBlocker.ts\",\"../../src/injectCanGoBack.ts\",\"../../src/Link.ts\",\"../../src/injectIntersectionObserver.ts\",\"../../src/dynamicRenderer.ts\",\"../../src/routerInjectionToken.ts\",\"../../src/matchInjectorToken.ts\"],\"sourcesContent\":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],\"names\":[\"RouteCore\",\"RootRouteCore\"],\"mappings\":\"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\"}","type":"asset"}],"fesm2022":[{"exports":["MATCH_ID_INJECTOR_TOKEN","Matches","NotFoundRoute","Outlet","RootRoute","Route","RouteApi","RouteMatch","RouterProvider","createRootRoute","createRootRouteWithContext","createRoute","createRouteMask","createRouter","getRouteApi","getRouterInjectionKey","injectBlocker","injectCanGoBack","injectDynamicRenderer","injectIntersectionObserver","injectLoaderData","injectLoaderDeps","injectLocation","injectMatch","injectNavigate","injectParams","injectRouter","injectRouterContext","injectRouterState","injectSearch","rootRouteWithContext"],"facadeModuleId":"/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/tanstack-angular-router.js","isDynamicEntry":false,"isEntry":true,"isImplicitEntry":false,"moduleIds":["/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/router.js","/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/matchInjectorToken.js","/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/routerInjectionToken.js","/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/injectRouter.js","/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/injectRouterState.js","/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/injectMatch.js","/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/injectLoaderData.js","/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/injectLoaderDeps.js","/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/injectParams.js","/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/injectSearch.js","/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/injectNavigate.js","/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/route.js","/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/dynamicRenderer.js","/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/DefaultNotFound.js","/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/Match.js","/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/transitioner.js","/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/Macthes.js","/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/RouterProvider.js","/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/injectRouteContext.js","/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/injectLocationResult.js","/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/injectBlocker.js","/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/injectCanGoBack.js","/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/injectIntersectionObserver.js","/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/index.js","/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/tanstack-angular-router.js"],"name":"tanstack-angular-router","type":"chunk","dynamicImports":[],"fileName":"tanstack-angular-router.mjs","implicitlyLoadedBefore":[],"importedBindings":{"@tanstack/router-core":["RouterCore","BaseRouteApi","notFound","BaseRoute","BaseRootRoute","getLocationChangeInfo","rootRouteId","createControlledPromise","trimPathRight","handleHashScroll"],"@angular/core":["InjectionToken","signal","inject","computed","ViewContainerRef","Injector","DestroyRef","inputBinding","*","ChangeDetectionStrategy","Component","effect","input","afterNextRender","untracked","ElementRef","afterRenderEffect"],"@tanstack/angular-store":["injectStore"],"tiny-warning":["default"]},"imports":["@tanstack/router-core","@angular/core","@tanstack/angular-store","tiny-warning"],"modules":{"/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/router.js":{"code":"const createRouter = (options) => {\n    return new Router(options);\n};\nclass Router extends RouterCore {\n    constructor(options) {\n        super(options);\n    }\n}","originalLength":265,"removedExports":[],"renderedExports":["createRouter","Router"],"renderedLength":163},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/matchInjectorToken.js":{"code":"const MATCH_ID_INJECTOR_TOKEN = new InjectionToken('MATCH_ID_INJECTOR', {\n    factory: () => signal(undefined),\n});","originalLength":225,"removedExports":[],"renderedExports":["MATCH_ID_INJECTOR_TOKEN"],"renderedLength":115},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/routerInjectionToken.js":{"code":"const routerInjectionKey = new InjectionToken('ROUTER');\nfunction getRouterInjectionKey() {\n    if (typeof document === 'undefined') {\n        return routerInjectionKey;\n    }\n    if (window.__TSR_ROUTER_INJECTION_KEY__) {\n        return window.__TSR_ROUTER_INJECTION_KEY__;\n    }\n    window.__TSR_ROUTER_INJECTION_KEY__ = routerInjectionKey;\n    return routerInjectionKey;\n}","originalLength":479,"removedExports":[],"renderedExports":["getRouterInjectionKey"],"renderedLength":375},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/injectRouter.js":{"code":"function injectRouter(opts) {\n    const router = inject(getRouterInjectionKey(), { optional: true });\n    warning(!((opts?.warn ?? true) && !router), 'No router found in the injector contetext for injectRouter!');\n    return router;\n}","originalLength":422,"removedExports":[],"renderedExports":["injectRouter"],"renderedLength":234},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/injectRouterState.js":{"code":"function injectRouterState(opts) {\n    const contextRouter = injectRouter({\n        warn: opts?.router === undefined,\n    });\n    const router = opts?.router ?? contextRouter;\n    return injectStore(router.__store, (state) => {\n        if (opts?.select)\n            return opts.select(state);\n        return state;\n    });\n}","originalLength":479,"removedExports":[],"renderedExports":["injectRouterState"],"renderedLength":324},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/injectMatch.js":{"code":"function injectMatch(opts) {\n    const nearestMatchId = inject(MATCH_ID_INJECTOR_TOKEN);\n    const matchState = injectRouterState({\n        select: (state) => {\n            const match = state.matches.find((d) => opts.from ? opts.from === d.routeId : d.id === nearestMatchId());\n            if (match === undefined) {\n                // During navigation transitions, check if the match exists in pendingMatches\n                const pendingMatch = state.pendingMatches?.find((d) => opts.from ? opts.from === d.routeId : d.id === nearestMatchId());\n                // Determine if we should throw an error\n                const shouldThrowError = !pendingMatch && !state.isTransitioning && (opts.shouldThrow ?? true);\n                return {\n                    match: undefined,\n                    shouldThrowError,\n                };\n            }\n            return {\n                match: opts.select ? opts.select(match) : match,\n                shouldThrowError: false,\n            };\n        },\n    });\n    // Throw the error if we have one - this happens after the selector runs\n    // Using a computed so the error is thrown when the return value is accessed\n    return computed(() => {\n        const state = matchState();\n        if (state.shouldThrowError) {\n            throw new Error(`Could not find ${opts.from ? `an active match from \"${opts.from}\"` : 'a nearest match!'}`);\n        }\n        return state.match;\n    });\n}","originalLength":1659,"removedExports":[],"renderedExports":["injectMatch"],"renderedLength":1441},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/injectLoaderData.js":{"code":"function injectLoaderData(opts) {\n    return injectMatch({\n        from: opts.from,\n        strict: opts.strict,\n        select: (s) => opts.select ? opts.select(s.loaderData) : s.loaderData,\n    });\n}","originalLength":298,"removedExports":[],"renderedExports":["injectLoaderData"],"renderedLength":201},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/injectLoaderDeps.js":{"code":"function injectLoaderDeps(opts) {\n    const { select, ...rest } = opts;\n    return injectMatch({\n        ...rest,\n        select: (s) => (select ? select(s.loaderDeps) : s.loaderDeps),\n    });\n}","originalLength":291,"removedExports":[],"renderedExports":["injectLoaderDeps"],"renderedLength":194},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/injectParams.js":{"code":"function injectParams(opts) {\n    return injectMatch({\n        from: opts.from,\n        strict: opts.strict,\n        shouldThrow: opts.shouldThrow,\n        select: (match) => {\n            const params = opts.strict === false ? match.params : match._strictParams;\n            return opts.select ? opts.select(params) : params;\n        },\n    });\n}","originalLength":440,"removedExports":[],"renderedExports":["injectParams"],"renderedLength":347},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/injectSearch.js":{"code":"function injectSearch(opts) {\n    return injectMatch({\n        from: opts.from,\n        strict: opts.strict,\n        shouldThrow: opts.shouldThrow,\n        select: (match) => {\n            return opts.select ? opts.select(match.search) : match.search;\n        },\n    });\n}","originalLength":365,"removedExports":[],"renderedExports":["injectSearch"],"renderedLength":272},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/injectNavigate.js":{"code":"function injectNavigate(_defaultOpts) {\n    const router = injectRouter();\n    return ((options) => {\n        return router.navigate({\n            ...options,\n            from: options.from ?? _defaultOpts?.from,\n        });\n    });\n}","originalLength":331,"removedExports":[],"renderedExports":["injectNavigate"],"renderedLength":234},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/route.js":{"code":"function getRouteApi(id) {\n    return new RouteApi({ id });\n}\nclass RouteApi extends BaseRouteApi {\n    /**\n     * @deprecated Use the `getRouteApi` function instead.\n     */\n    constructor({ id }) {\n        super({ id });\n        this.injectMatch = (opts) => {\n            return injectMatch({\n                select: opts?.select,\n                from: this.id,\n            });\n        };\n        this.injectRouteContext = (opts) => {\n            return injectMatch({\n                from: this.id,\n                select: (d) => (opts?.select ? opts.select(d.context) : d.context),\n            });\n        };\n        this.injectSearch = (opts) => {\n            return injectSearch({\n                select: opts?.select,\n                from: this.id,\n            });\n        };\n        this.injectParams = (opts) => {\n            return injectParams({\n                select: opts?.select,\n                from: this.id,\n            });\n        };\n        this.injectLoaderDeps = (opts) => {\n            return injectLoaderDeps({ ...opts, from: this.id, strict: false });\n        };\n        this.injectLoaderData = (opts) => {\n            return injectLoaderData({ ...opts, from: this.id, strict: false });\n        };\n        this.injectNavigate = () => {\n            const router = injectRouter();\n            return injectNavigate({\n                from: router.routesById[this.id].fullPath,\n            });\n        };\n        this.notFound = (opts) => {\n            return notFound({ routeId: this.id, ...opts });\n        };\n    }\n}\nclass Route extends BaseRoute {\n    /**\n     * @deprecated Use the `createRoute` function instead.\n     */\n    constructor(options) {\n        super(options);\n        this.injectMatch = (opts) => {\n            return injectMatch({\n                select: opts?.select,\n                from: this.id,\n            });\n        };\n        this.injectRouteContext = (opts) => {\n            return injectMatch({\n                ...opts,\n                from: this.id,\n                select: (d) => (opts?.select ? opts.select(d.context) : d.context),\n            });\n        };\n        this.injectSearch = (opts) => {\n            return injectSearch({\n                select: opts?.select,\n                from: this.id,\n            });\n        };\n        this.injectParams = (opts) => {\n            return injectParams({\n                select: opts?.select,\n                from: this.id,\n            });\n        };\n        this.injectLoaderDeps = (opts) => {\n            return injectLoaderDeps({ ...opts, from: this.id });\n        };\n        this.injectLoaderData = (opts) => {\n            return injectLoaderData({ ...opts, from: this.id });\n        };\n        this.injectNavigate = () => {\n            return injectNavigate({ from: this.fullPath });\n        };\n    }\n}\nfunction createRoute(options) {\n    return new Route(options);\n}\nfunction createRootRouteWithContext() {\n    return (options) => {\n        return createRootRoute(options);\n    };\n}\n/**\n * @deprecated Use the `createRootRouteWithContext` function instead.\n */\nconst rootRouteWithContext = createRootRouteWithContext;\nclass RootRoute extends BaseRootRoute {\n    /**\n     * @deprecated `RootRoute` is now an internal implementation detail. Use `createRootRoute()` instead.\n     */\n    constructor(options) {\n        super(options);\n        this.injectMatch = (opts) => {\n            return injectMatch({\n                select: opts?.select,\n                from: this.id,\n            });\n        };\n        this.injectRouteContext = (opts) => {\n            return injectMatch({\n                ...opts,\n                from: this.id,\n                select: (d) => (opts?.select ? opts.select(d.context) : d.context),\n            });\n        };\n        this.injectSearch = (opts) => {\n            return injectSearch({\n                select: opts?.select,\n                from: this.id,\n            });\n        };\n        this.injectParams = (opts) => {\n            return injectParams({\n                select: opts?.select,\n                from: this.id,\n            });\n        };\n        this.injectLoaderDeps = (opts) => {\n            return injectLoaderDeps({ ...opts, from: this.id });\n        };\n        this.injectLoaderData = (opts) => {\n            return injectLoaderData({ ...opts, from: this.id });\n        };\n        this.injectNavigate = () => {\n            return injectNavigate({ from: this.fullPath });\n        };\n    }\n}\nfunction createRouteMask(opts) {\n    return opts;\n}\nclass NotFoundRoute extends Route {\n    constructor(options) {\n        super({\n            ...options,\n            id: '404',\n        });\n    }\n}\nfunction createRootRoute(options) {\n    return new RootRoute(options);\n}","originalLength":5262,"removedExports":[],"renderedExports":["getRouteApi","RouteApi","Route","createRoute","createRootRouteWithContext","rootRouteWithContext","RootRoute","createRouteMask","NotFoundRoute","createRootRoute"],"renderedLength":4720},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/dynamicRenderer.js":{"code":"function injectDynamicRenderer() {\n    const vcr = inject(ViewContainerRef);\n    const parent = inject(Injector);\n    inject(DestroyRef).onDestroy(() => {\n        vcr.clear();\n    });\n    let lastComponent = null;\n    let lastKey = null;\n    const clear = () => {\n        if (lastComponent)\n            vcr.clear();\n        lastComponent = null;\n        lastKey = null;\n    };\n    return {\n        clear,\n        render: ({ component, providers = [], key, inputs }) => {\n            if (lastComponent === component && lastKey === key) {\n                return;\n            }\n            vcr.clear();\n            if (!component)\n                return;\n            const injector = Injector.create({ providers, parent });\n            const bindings = Object.entries(inputs ?? {}).map(([name, value]) => inputBinding(name, value));\n            const cmpRef = vcr.createComponent(component, { injector, bindings });\n            cmpRef.changeDetectorRef.markForCheck();\n            lastComponent = component;\n            lastKey = key ?? null;\n        },\n    };\n}","originalLength":1205,"removedExports":[],"renderedExports":["injectDynamicRenderer"],"renderedLength":1059},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/DefaultNotFound.js":{"code":"class DefaultNotFoundComponent {\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.4\", ngImport: i0, type: DefaultNotFoundComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }\n    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"21.0.4\", type: DefaultNotFoundComponent, isStandalone: true, selector: \"ng-component\", host: { styleAttribute: \"display: contents;\" }, ngImport: i0, template: `<p>Not found</p>`, isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.4\", ngImport: i0, type: DefaultNotFoundComponent, decorators: [{\n            type: Component,\n            args: [{\n                    template: `<p>Not found</p>`,\n                    changeDetection: ChangeDetectionStrategy.OnPush,\n                    host: { style: 'display: contents;' },\n                }]\n        }] });","originalLength":1108,"removedExports":[],"renderedExports":["DefaultNotFoundComponent"],"renderedLength":952},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/Match.js":{"code":"// In Angular, there is not concept of suspense or error boundaries,\n// so we dont' need to wrap the inner content of the match.\n// So in this adapter, we use derived state instead of state boundaries.\n// Equivalent to the OnRendered component.\nfunction injectOnRendered({ parentRouteId, rootRouteId, }) {\n    const router = injectRouter({ warn: false });\n    const location = injectRouterState({\n        select: (s) => s.resolvedLocation?.state.key,\n    });\n    const isRootRoute = computed(() => parentRouteId() === rootRouteId(), ...(ngDevMode ? [{ debugName: \"isRootRoute\" }] : []));\n    effect(() => {\n        if (!isRootRoute())\n            return;\n        location(); // Track location\n        router.emit({\n            type: 'onRendered',\n            ...getLocationChangeInfo(router.state),\n        });\n    });\n}\nclass RouteMatch {\n    constructor() {\n        this.matchId = input.required(...(ngDevMode ? [{ debugName: \"matchId\" }] : []));\n        this.router = injectRouter();\n        this.matchData = injectRouterState({\n            select: (s) => {\n                const matchIndex = s.matches.findIndex((d) => d.id === this.matchId());\n                if (matchIndex === -1)\n                    return null;\n                const match = s.matches[matchIndex];\n                const parentRouteId = matchIndex > 0 ? s.matches[matchIndex - 1]?.routeId : null;\n                const routeId = match.routeId;\n                const route = this.router.routesById[routeId];\n                const remountFn = route.options.remountDeps ?? this.router.options.defaultRemountDeps;\n                const remountDeps = remountFn?.({\n                    routeId,\n                    loaderDeps: match.loaderDeps,\n                    params: match._strictParams,\n                    search: match._strictSearch,\n                });\n                const key = remountDeps ? JSON.stringify(remountDeps) : undefined;\n                return {\n                    key,\n                    route,\n                    match,\n                    parentRouteId,\n                };\n            },\n        });\n        this.isFistRouteInRouteTree = computed(() => this.matchData()?.parentRouteId === rootRouteId, ...(ngDevMode ? [{ debugName: \"isFistRouteInRouteTree\" }] : []));\n        this.resolvedNoSsr = computed(() => {\n            const match = this.matchData()?.match;\n            if (!match)\n                return true;\n            return match.ssr === false || match.ssr === 'data-only';\n        }, ...(ngDevMode ? [{ debugName: \"resolvedNoSsr\" }] : []));\n        this.shouldClientOnly = computed(() => {\n            const match = this.matchData()?.match;\n            if (!match)\n                return true;\n            return this.resolvedNoSsr() || !!match._displayPending;\n        }, ...(ngDevMode ? [{ debugName: \"shouldClientOnly\" }] : []));\n        this.rendering = injectDynamicRenderer();\n        this.render = effect(() => {\n            const matchData = this.matchData();\n            if (!matchData)\n                return;\n            if (this.shouldClientOnly() && this.router.isServer) {\n                this.rendering.clear();\n                return;\n            }\n            const { match, route } = matchData;\n            if (match.status === 'notFound') {\n                const NotFoundComponent = getNotFoundComponent(this.router, route);\n                this.rendering.render({ component: NotFoundComponent });\n            }\n            else if (match.status === 'error') {\n                const RouteErrorComponent = route.options.errorComponent ??\n                    this.router.options.defaultErrorComponent;\n                this.rendering.render({\n                    component: RouteErrorComponent || null,\n                    inputs: {\n                        error: () => match.error,\n                        reset: () => {\n                            this.router.invalidate();\n                        },\n                        info: () => {\n                            return { componentStack: '' };\n                        },\n                    },\n                });\n            }\n            else if (match._forcePending ||\n                match._displayPending ||\n                match.status === 'redirected' ||\n                match.status === 'pending') {\n                const pendingMinMs = route.options.pendingMinMs ?? this.router.options.defaultPendingMinMs;\n                // If the compoennt is pending and has a minPendingMs,\n                // we create a promise that will be awaited in the route core\n                // to ensure that the pending state is displayed for that amount of time\n                if (match.status === 'pending' &&\n                    pendingMinMs &&\n                    !match._nonReactive.minPendingPromise &&\n                    !this.router.isServer) {\n                    const minPendingPromise = createControlledPromise();\n                    match._nonReactive.minPendingPromise = minPendingPromise;\n                    setTimeout(() => {\n                        minPendingPromise.resolve();\n                        match._nonReactive.minPendingPromise = undefined;\n                    }, pendingMinMs);\n                }\n                const PendingComponent = route.options.pendingComponent ??\n                    this.router.options.defaultPendingComponent;\n                this.rendering.render({ component: PendingComponent });\n            }\n            else if (match.status === 'success') {\n                const Component = route.options.component ??\n                    this.router.options.defaultComponent ??\n                    Outlet;\n                const key = matchData.key;\n                const matchIdSignal = computed(() => this.matchId());\n                this.rendering.render({\n                    key,\n                    component: Component,\n                    providers: [\n                        {\n                            provide: MATCH_ID_INJECTOR_TOKEN,\n                            useValue: matchIdSignal,\n                        },\n                    ],\n                });\n            }\n        }, ...(ngDevMode ? [{ debugName: \"render\" }] : []));\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.4\", ngImport: i0, type: RouteMatch, deps: [], target: i0.ɵɵFactoryTarget.Component }); }\n    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"17.1.0\", version: \"21.0.4\", type: RouteMatch, isStandalone: true, selector: \"router-match\", inputs: { matchId: { classPropertyName: \"matchId\", publicName: \"matchId\", isSignal: true, isRequired: true, transformFunction: null } }, host: { properties: { \"attr.data-matchId\": \"matchId()\" } }, ngImport: i0, template: '', isInline: true }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.4\", ngImport: i0, type: RouteMatch, decorators: [{\n            type: Component,\n            args: [{\n                    selector: 'router-match',\n                    template: '',\n                    standalone: true,\n                    host: {\n                        '[attr.data-matchId]': 'matchId()',\n                    },\n                }]\n        }], propDecorators: { matchId: [{ type: i0.Input, args: [{ isSignal: true, alias: \"matchId\", required: true }] }] } });\nclass Outlet {\n    constructor() {\n        this.router = injectRouter();\n        this.matchId = inject(MATCH_ID_INJECTOR_TOKEN);\n        this.routeId = injectRouterState({\n            select: (s) => s.matches.find((d) => d.id === this.matchId())?.routeId,\n        });\n        this.route = computed(() => this.router.routesById[this.routeId()], ...(ngDevMode ? [{ debugName: \"route\" }] : []));\n        this.parentGlobalNotFound = injectRouterState({\n            select: (s) => {\n                const matches = s.matches;\n                const parentMatch = matches.find((d) => d.id === this.matchId());\n                if (!parentMatch)\n                    return false;\n                return parentMatch.globalNotFound;\n            },\n        });\n        this.childMatchId = injectRouterState({\n            select: (s) => {\n                const matches = s.matches;\n                const index = matches.findIndex((d) => d.id === this.matchId());\n                const child = matches[index + 1];\n                if (!child)\n                    return null;\n                return child.id;\n            },\n        });\n        this.rendering = injectDynamicRenderer();\n        this.render = effect(() => {\n            if (this.parentGlobalNotFound()) {\n                // Render not found with warning\n                const NotFoundComponent = getNotFoundComponent(this.router, this.route());\n                this.rendering.render({ component: NotFoundComponent });\n                return;\n            }\n            const childMatchId = this.childMatchId();\n            if (!childMatchId) {\n                // Do not render anything\n                this.rendering.clear();\n                return;\n            }\n            this.rendering.render({\n                component: RouteMatch,\n                inputs: {\n                    matchId: () => this.childMatchId(),\n                },\n            });\n        }, ...(ngDevMode ? [{ debugName: \"render\" }] : []));\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.4\", ngImport: i0, type: Outlet, deps: [], target: i0.ɵɵFactoryTarget.Component }); }\n    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"21.0.4\", type: Outlet, isStandalone: true, selector: \"outlet\", ngImport: i0, template: '', isInline: true }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.4\", ngImport: i0, type: Outlet, decorators: [{\n            type: Component,\n            args: [{\n                    selector: 'outlet',\n                    template: '',\n                    standalone: true,\n                }]\n        }] });\nfunction getNotFoundComponent(router, route) {\n    let NotFoundComponent = route.options.notFoundComponent ?? router.options.defaultNotFoundComponent;\n    if (NotFoundComponent) {\n        return NotFoundComponent;\n    }\n    if (process.env.NODE_ENV === 'development') {\n        warning(route.options.notFoundComponent, `A notFoundError was encountered on the route with ID \"${route.id}\", but a notFoundComponent option was not configured, nor was a router level defaultNotFoundComponent configured. Consider configuring at least one of these to avoid TanStack Router's overly generic defaultNotFoundComponent (<p>Page not found</p>)`);\n    }\n    return DefaultNotFoundComponent;\n}","originalLength":11218,"removedExports":[],"renderedExports":["RouteMatch","Outlet"],"renderedLength":10629},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/transitioner.js":{"code":"// Track mount state per router to avoid double-loading\nlet mountLoadForRouter = {\n    router: null,\n    mounted: false,\n};\n/**\n * Helper function that sets up router transition logic.\n * This should be called from Matches component to set up:\n * - router.startTransition\n * - router.startViewTransition\n * - History subscription\n * - Router event watchers\n *\n * Must be called during component initialization.\n */\nfunction injectTransitionerSetup() {\n    const router = injectRouter();\n    // Skip on server - no transitions needed\n    if (router.isServer) {\n        return;\n    }\n    const destroyRef = inject(DestroyRef);\n    const isLoading = injectRouterState({\n        select: (s) => s.isLoading,\n    });\n    // Track if we're in a transition\n    const isTransitioning = signal(false, ...(ngDevMode ? [{ debugName: \"isTransitioning\" }] : []));\n    // Track pending state changes\n    const hasPendingMatches = injectRouterState({\n        select: (s) => s.matches.some((d) => d.status === 'pending'),\n    });\n    // Track previous values for comparison\n    let previousIsLoading;\n    let previousIsAnyPending;\n    let previousIsPagePending;\n    const isAnyPending = computed(() => isLoading() || isTransitioning() || hasPendingMatches(), ...(ngDevMode ? [{ debugName: \"isAnyPending\" }] : []));\n    const isPagePending = computed(() => isLoading() || hasPendingMatches(), ...(ngDevMode ? [{ debugName: \"isPagePending\" }] : []));\n    // Implement startTransition similar to React/Solid\n    // Angular doesn't have a native startTransition like React 18, so we simulate it\n    router.startTransition = (fn) => {\n        isTransitioning.set(true);\n        // Also update the router state so useMatch can check it\n        try {\n            router.__store.setState((s) => ({ ...s, isTransitioning: true }));\n        }\n        catch {\n            // Ignore errors if component is unmounted\n        }\n        // Execute the function\n        const result = fn();\n        // Handle async functions\n        if (result instanceof Promise) {\n            result\n                .then(() => {\n                isTransitioning.set(false);\n                try {\n                    router.__store.setState((s) => ({ ...s, isTransitioning: false }));\n                }\n                catch {\n                    // Ignore errors if component is unmounted\n                }\n            })\n                .catch(() => {\n                isTransitioning.set(false);\n                try {\n                    router.__store.setState((s) => ({ ...s, isTransitioning: false }));\n                }\n                catch {\n                    // Ignore errors if component is unmounted\n                }\n            });\n        }\n        else {\n            // For sync functions, use setTimeout to allow Angular to process updates\n            setTimeout(() => {\n                isTransitioning.set(false);\n                try {\n                    router.__store.setState((s) => ({ ...s, isTransitioning: false }));\n                }\n                catch {\n                    // Ignore errors if component is unmounted\n                }\n            }, 0);\n        }\n    };\n    // Angular doesn't have View Transitions API support like Vue, but we can still\n    // set up the function for compatibility\n    const originalStartViewTransition = router.__tsrOriginalStartViewTransition ??\n        router.startViewTransition;\n    router.__tsrOriginalStartViewTransition =\n        originalStartViewTransition;\n    router.startViewTransition = (fn) => {\n        return originalStartViewTransition?.(fn);\n    };\n    // Subscribe to location changes and try to load the new location\n    let unsubscribe;\n    afterNextRender(() => {\n        unsubscribe = router.history.subscribe(router.load);\n        const nextLocation = router.buildLocation({\n            to: router.latestLocation.pathname,\n            search: true,\n            params: true,\n            hash: true,\n            state: true,\n            _includeValidateSearch: true,\n        });\n        if (trimPathRight(router.latestLocation.href) !==\n            trimPathRight(nextLocation.href)) {\n            router.commitLocation({ ...nextLocation, replace: true });\n        }\n    });\n    // Track if component is mounted to prevent updates after unmount\n    const isMounted = signal(false, ...(ngDevMode ? [{ debugName: \"isMounted\" }] : []));\n    afterNextRender(() => {\n        isMounted.set(true);\n        if (!isAnyPending()) {\n            router.__store.setState((s) => s.status === 'pending'\n                ? { ...s, status: 'idle', resolvedLocation: s.location }\n                : s);\n        }\n    });\n    destroyRef.onDestroy(() => {\n        isMounted.set(false);\n        if (unsubscribe) {\n            unsubscribe();\n        }\n    });\n    // Try to load the initial location\n    afterNextRender(() => {\n        if ((typeof window !== 'undefined' && router.ssr) ||\n            (mountLoadForRouter.router === router && mountLoadForRouter.mounted)) {\n            return;\n        }\n        mountLoadForRouter = { router, mounted: true };\n        const tryLoad = async () => {\n            try {\n                await router.load();\n            }\n            catch (err) {\n                console.error(err);\n            }\n        };\n        tryLoad();\n    });\n    // Setup effects for emitting events\n    // All effects check isMounted to prevent updates after unmount\n    // Watch for onLoad event\n    effect(() => {\n        if (!isMounted())\n            return;\n        const currentIsLoading = isLoading();\n        try {\n            if (previousIsLoading && !currentIsLoading) {\n                router.emit({\n                    type: 'onLoad',\n                    ...getLocationChangeInfo(router.state),\n                });\n            }\n            previousIsLoading = currentIsLoading;\n        }\n        catch {\n            // Ignore errors if component is unmounted\n        }\n    });\n    // Watch for onBeforeRouteMount event\n    effect(() => {\n        if (!isMounted())\n            return;\n        const currentIsPagePending = isPagePending();\n        try {\n            if (previousIsPagePending && !currentIsPagePending) {\n                router.emit({\n                    type: 'onBeforeRouteMount',\n                    ...getLocationChangeInfo(router.state),\n                });\n            }\n            previousIsPagePending = currentIsPagePending;\n        }\n        catch {\n            // Ignore errors if component is unmounted\n        }\n    });\n    // Watch for onResolved event\n    effect(() => {\n        if (!isMounted())\n            return;\n        const currentIsAnyPending = isAnyPending();\n        try {\n            if (!currentIsAnyPending && router.__store.state.status === 'pending') {\n                router.__store.setState((s) => ({\n                    ...s,\n                    status: 'idle',\n                    resolvedLocation: s.location,\n                }));\n            }\n            // The router was pending and now it's not\n            if (previousIsAnyPending && !currentIsAnyPending) {\n                const changeInfo = getLocationChangeInfo(router.state);\n                router.emit({\n                    type: 'onResolved',\n                    ...changeInfo,\n                });\n                if (changeInfo.hrefChanged) {\n                    handleHashScroll(router);\n                }\n            }\n            previousIsAnyPending = currentIsAnyPending;\n        }\n        catch {\n            // Ignore errors if component is unmounted\n        }\n    });\n}","originalLength":7884,"removedExports":[],"renderedExports":["injectTransitionerSetup"],"renderedLength":7539},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/Macthes.js":{"code":"class Matches {\n    constructor() {\n        this.matchId = injectRouterState({\n            select: (s) => s.matches[0]?.id,\n        });\n        this.renderer = injectDynamicRenderer();\n        this.transitioner = injectTransitionerSetup();\n        this.render = effect(() => {\n            const matchId = this.matchId();\n            if (!matchId) {\n                this.renderer.clear();\n                return;\n            }\n            this.renderer.render({\n                component: RouteMatch,\n                inputs: {\n                    matchId: () => matchId,\n                },\n            });\n        }, ...(ngDevMode ? [{ debugName: \"render\" }] : []));\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.4\", ngImport: i0, type: Matches, deps: [], target: i0.ɵɵFactoryTarget.Component }); }\n    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"21.0.4\", type: Matches, isStandalone: true, selector: \"router-matches\", ngImport: i0, template: '', isInline: true }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.4\", ngImport: i0, type: Matches, decorators: [{\n            type: Component,\n            args: [{ selector: 'router-matches', template: '', standalone: true }]\n        }] });","originalLength":1634,"removedExports":[],"renderedExports":["Matches"],"renderedLength":1291},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/RouterProvider.js":{"code":"class RouterProvider {\n    constructor() {\n        this.router = input.required(...(ngDevMode ? [{ debugName: \"router\" }] : []));\n        this.renderer = injectDynamicRenderer();\n        this.render = effect(() => {\n            const router = untracked(this.router);\n            this.renderer.render({\n                component: Matches,\n                providers: [\n                    {\n                        provide: getRouterInjectionKey(),\n                        useValue: router,\n                    },\n                ],\n            });\n        }, ...(ngDevMode ? [{ debugName: \"render\" }] : []));\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.4\", ngImport: i0, type: RouterProvider, deps: [], target: i0.ɵɵFactoryTarget.Component }); }\n    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"17.1.0\", version: \"21.0.4\", type: RouterProvider, isStandalone: true, selector: \"router-provider\", inputs: { router: { classPropertyName: \"router\", publicName: \"router\", isSignal: true, isRequired: true, transformFunction: null } }, ngImport: i0, template: '', isInline: true }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.4\", ngImport: i0, type: RouterProvider, decorators: [{\n            type: Component,\n            args: [{ selector: 'router-provider', template: '', standalone: true }]\n        }], propDecorators: { router: [{ type: i0.Input, args: [{ isSignal: true, alias: \"router\", required: true }] }] } });","originalLength":1817,"removedExports":[],"renderedExports":["RouterProvider"],"renderedLength":1501},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/injectRouteContext.js":{"code":"function injectRouterContext(opts) {\n    return injectMatch({\n        ...opts,\n        select: (match) => opts.select ? opts.select(match.context) : match.context,\n    });\n}","originalLength":272,"removedExports":[],"renderedExports":["injectRouterContext"],"renderedLength":173},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/injectLocationResult.js":{"code":"function injectLocation(opts) {\n    return injectRouterState({\n        select: (s) => (opts.select ? opts.select(s.location) : s.location),\n    });\n}","originalLength":262,"removedExports":[],"renderedExports":["injectLocation"],"renderedLength":149},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/injectBlocker.js":{"code":"function injectBlocker(opts) {\n    const shouldBlockFn = opts.shouldBlockFn;\n    const router = injectRouter();\n    const resolver = signal({\n        status: 'idle',\n        current: undefined,\n        next: undefined,\n        action: undefined,\n        proceed: undefined,\n        reset: undefined,\n    }, ...(ngDevMode ? [{ debugName: \"resolver\" }] : []));\n    effect((onCleanup) => {\n        const blockerFnComposed = async (blockerFnArgs) => {\n            function getLocation(location) {\n                const parsedLocation = router.parseLocation(location);\n                const matchedRoutes = router.getMatchedRoutes(parsedLocation.pathname);\n                if (matchedRoutes.foundRoute === undefined) {\n                    return {\n                        routeId: '__notFound__',\n                        fullPath: parsedLocation.pathname,\n                        pathname: parsedLocation.pathname,\n                        params: matchedRoutes.routeParams,\n                        search: parsedLocation.search,\n                    };\n                }\n                return {\n                    routeId: matchedRoutes.foundRoute.id,\n                    fullPath: matchedRoutes.foundRoute.fullPath,\n                    pathname: parsedLocation.pathname,\n                    params: matchedRoutes.routeParams,\n                    search: parsedLocation.search,\n                };\n            }\n            const current = getLocation(blockerFnArgs.currentLocation);\n            const next = getLocation(blockerFnArgs.nextLocation);\n            if (current.routeId === '__notFound__' &&\n                next.routeId !== '__notFound__') {\n                return false;\n            }\n            const shouldBlock = await shouldBlockFn({\n                action: blockerFnArgs.action,\n                current,\n                next,\n            });\n            if (!opts.withResolver) {\n                return shouldBlock;\n            }\n            if (!shouldBlock) {\n                return false;\n            }\n            const promise = new Promise((resolve) => {\n                resolver.set({\n                    status: 'blocked',\n                    current,\n                    next,\n                    action: blockerFnArgs.action,\n                    proceed: () => resolve(false),\n                    reset: () => resolve(true),\n                });\n            });\n            const canNavigateAsync = await promise;\n            resolver.set({\n                status: 'idle',\n                current: undefined,\n                next: undefined,\n                action: undefined,\n                proceed: undefined,\n                reset: undefined,\n            });\n            return canNavigateAsync;\n        };\n        const disposeBlock = opts.disabled\n            ? undefined\n            : router.history.block({\n                blockerFn: blockerFnComposed,\n                enableBeforeUnload: opts.enableBeforeUnload,\n            });\n        onCleanup(() => disposeBlock?.());\n    });\n    return resolver.asReadonly();\n}","originalLength":3192,"removedExports":[],"renderedExports":["injectBlocker"],"renderedLength":3048},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/injectCanGoBack.js":{"code":"function injectCanGoBack() {\n    return injectRouterState({\n        select: (s) => s.location.state.__TSR_index !== 0,\n    });\n}","originalLength":236,"removedExports":[],"renderedExports":["injectCanGoBack"],"renderedLength":128},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/injectIntersectionObserver.js":{"code":"function injectIntersectionObserver(callback, intersectionObserverOptions, disabled) {\n    const elementRef = inject(ElementRef);\n    afterRenderEffect((onCleanup) => {\n        const isDisabled = disabled();\n        const element = elementRef.nativeElement;\n        if (isDisabled || !element)\n            return;\n        const observer = new IntersectionObserver(([entry]) => callback(entry), intersectionObserverOptions);\n        observer.observe(element);\n        onCleanup(() => {\n            observer.disconnect();\n        });\n    });\n}","originalLength":675,"removedExports":[],"renderedExports":["injectIntersectionObserver"],"renderedLength":541},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/index.js":{"code":"// Router","originalLength":1379,"removedExports":[],"renderedExports":[],"renderedLength":9},"/Users/bv/Repos/router/packages/angular-router/dist/tmp-esm2022/tanstack-angular-router.js":{"code":"/**\n * Generated bundle index. Do not edit.\n */","originalLength":124,"removedExports":[],"renderedExports":[],"renderedLength":47}},"referencedFiles":[],"code":"import { RouterCore, BaseRouteApi, notFound, BaseRoute, BaseRootRoute, getLocationChangeInfo, rootRouteId, createControlledPromise, trimPathRight, handleHashScroll } from '@tanstack/router-core';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, signal, inject, computed, ViewContainerRef, Injector, DestroyRef, inputBinding, ChangeDetectionStrategy, Component, effect, input, afterNextRender, untracked, ElementRef, afterRenderEffect } from '@angular/core';\nimport { injectStore } from '@tanstack/angular-store';\nimport warning from 'tiny-warning';\n\nconst createRouter = (options) => {\n    return new Router(options);\n};\nclass Router extends RouterCore {\n    constructor(options) {\n        super(options);\n    }\n}\n\nconst MATCH_ID_INJECTOR_TOKEN = new InjectionToken('MATCH_ID_INJECTOR', {\n    factory: () => signal(undefined),\n});\n\nconst routerInjectionKey = new InjectionToken('ROUTER');\nfunction getRouterInjectionKey() {\n    if (typeof document === 'undefined') {\n        return routerInjectionKey;\n    }\n    if (window.__TSR_ROUTER_INJECTION_KEY__) {\n        return window.__TSR_ROUTER_INJECTION_KEY__;\n    }\n    window.__TSR_ROUTER_INJECTION_KEY__ = routerInjectionKey;\n    return routerInjectionKey;\n}\n\nfunction injectRouter(opts) {\n    const router = inject(getRouterInjectionKey(), { optional: true });\n    warning(!((opts?.warn ?? true) && !router), 'No router found in the injector contetext for injectRouter!');\n    return router;\n}\n\nfunction injectRouterState(opts) {\n    const contextRouter = injectRouter({\n        warn: opts?.router === undefined,\n    });\n    const router = opts?.router ?? contextRouter;\n    return injectStore(router.__store, (state) => {\n        if (opts?.select)\n            return opts.select(state);\n        return state;\n    });\n}\n\nfunction injectMatch(opts) {\n    const nearestMatchId = inject(MATCH_ID_INJECTOR_TOKEN);\n    const matchState = injectRouterState({\n        select: (state) => {\n            const match = state.matches.find((d) => opts.from ? opts.from === d.routeId : d.id === nearestMatchId());\n            if (match === undefined) {\n                // During navigation transitions, check if the match exists in pendingMatches\n                const pendingMatch = state.pendingMatches?.find((d) => opts.from ? opts.from === d.routeId : d.id === nearestMatchId());\n                // Determine if we should throw an error\n                const shouldThrowError = !pendingMatch && !state.isTransitioning && (opts.shouldThrow ?? true);\n                return {\n                    match: undefined,\n                    shouldThrowError,\n                };\n            }\n            return {\n                match: opts.select ? opts.select(match) : match,\n                shouldThrowError: false,\n            };\n        },\n    });\n    // Throw the error if we have one - this happens after the selector runs\n    // Using a computed so the error is thrown when the return value is accessed\n    return computed(() => {\n        const state = matchState();\n        if (state.shouldThrowError) {\n            throw new Error(`Could not find ${opts.from ? `an active match from \"${opts.from}\"` : 'a nearest match!'}`);\n        }\n        return state.match;\n    });\n}\n\nfunction injectLoaderData(opts) {\n    return injectMatch({\n        from: opts.from,\n        strict: opts.strict,\n        select: (s) => opts.select ? opts.select(s.loaderData) : s.loaderData,\n    });\n}\n\nfunction injectLoaderDeps(opts) {\n    const { select, ...rest } = opts;\n    return injectMatch({\n        ...rest,\n        select: (s) => (select ? select(s.loaderDeps) : s.loaderDeps),\n    });\n}\n\nfunction injectParams(opts) {\n    return injectMatch({\n        from: opts.from,\n        strict: opts.strict,\n        shouldThrow: opts.shouldThrow,\n        select: (match) => {\n            const params = opts.strict === false ? match.params : match._strictParams;\n            return opts.select ? opts.select(params) : params;\n        },\n    });\n}\n\nfunction injectSearch(opts) {\n    return injectMatch({\n        from: opts.from,\n        strict: opts.strict,\n        shouldThrow: opts.shouldThrow,\n        select: (match) => {\n            return opts.select ? opts.select(match.search) : match.search;\n        },\n    });\n}\n\nfunction injectNavigate(_defaultOpts) {\n    const router = injectRouter();\n    return ((options) => {\n        return router.navigate({\n            ...options,\n            from: options.from ?? _defaultOpts?.from,\n        });\n    });\n}\n\nfunction getRouteApi(id) {\n    return new RouteApi({ id });\n}\nclass RouteApi extends BaseRouteApi {\n    /**\n     * @deprecated Use the `getRouteApi` function instead.\n     */\n    constructor({ id }) {\n        super({ id });\n        this.injectMatch = (opts) => {\n            return injectMatch({\n                select: opts?.select,\n                from: this.id,\n            });\n        };\n        this.injectRouteContext = (opts) => {\n            return injectMatch({\n                from: this.id,\n                select: (d) => (opts?.select ? opts.select(d.context) : d.context),\n            });\n        };\n        this.injectSearch = (opts) => {\n            return injectSearch({\n                select: opts?.select,\n                from: this.id,\n            });\n        };\n        this.injectParams = (opts) => {\n            return injectParams({\n                select: opts?.select,\n                from: this.id,\n            });\n        };\n        this.injectLoaderDeps = (opts) => {\n            return injectLoaderDeps({ ...opts, from: this.id, strict: false });\n        };\n        this.injectLoaderData = (opts) => {\n            return injectLoaderData({ ...opts, from: this.id, strict: false });\n        };\n        this.injectNavigate = () => {\n            const router = injectRouter();\n            return injectNavigate({\n                from: router.routesById[this.id].fullPath,\n            });\n        };\n        this.notFound = (opts) => {\n            return notFound({ routeId: this.id, ...opts });\n        };\n    }\n}\nclass Route extends BaseRoute {\n    /**\n     * @deprecated Use the `createRoute` function instead.\n     */\n    constructor(options) {\n        super(options);\n        this.injectMatch = (opts) => {\n            return injectMatch({\n                select: opts?.select,\n                from: this.id,\n            });\n        };\n        this.injectRouteContext = (opts) => {\n            return injectMatch({\n                ...opts,\n                from: this.id,\n                select: (d) => (opts?.select ? opts.select(d.context) : d.context),\n            });\n        };\n        this.injectSearch = (opts) => {\n            return injectSearch({\n                select: opts?.select,\n                from: this.id,\n            });\n        };\n        this.injectParams = (opts) => {\n            return injectParams({\n                select: opts?.select,\n                from: this.id,\n            });\n        };\n        this.injectLoaderDeps = (opts) => {\n            return injectLoaderDeps({ ...opts, from: this.id });\n        };\n        this.injectLoaderData = (opts) => {\n            return injectLoaderData({ ...opts, from: this.id });\n        };\n        this.injectNavigate = () => {\n            return injectNavigate({ from: this.fullPath });\n        };\n    }\n}\nfunction createRoute(options) {\n    return new Route(options);\n}\nfunction createRootRouteWithContext() {\n    return (options) => {\n        return createRootRoute(options);\n    };\n}\n/**\n * @deprecated Use the `createRootRouteWithContext` function instead.\n */\nconst rootRouteWithContext = createRootRouteWithContext;\nclass RootRoute extends BaseRootRoute {\n    /**\n     * @deprecated `RootRoute` is now an internal implementation detail. Use `createRootRoute()` instead.\n     */\n    constructor(options) {\n        super(options);\n        this.injectMatch = (opts) => {\n            return injectMatch({\n                select: opts?.select,\n                from: this.id,\n            });\n        };\n        this.injectRouteContext = (opts) => {\n            return injectMatch({\n                ...opts,\n                from: this.id,\n                select: (d) => (opts?.select ? opts.select(d.context) : d.context),\n            });\n        };\n        this.injectSearch = (opts) => {\n            return injectSearch({\n                select: opts?.select,\n                from: this.id,\n            });\n        };\n        this.injectParams = (opts) => {\n            return injectParams({\n                select: opts?.select,\n                from: this.id,\n            });\n        };\n        this.injectLoaderDeps = (opts) => {\n            return injectLoaderDeps({ ...opts, from: this.id });\n        };\n        this.injectLoaderData = (opts) => {\n            return injectLoaderData({ ...opts, from: this.id });\n        };\n        this.injectNavigate = () => {\n            return injectNavigate({ from: this.fullPath });\n        };\n    }\n}\nfunction createRouteMask(opts) {\n    return opts;\n}\nclass NotFoundRoute extends Route {\n    constructor(options) {\n        super({\n            ...options,\n            id: '404',\n        });\n    }\n}\nfunction createRootRoute(options) {\n    return new RootRoute(options);\n}\n\nfunction injectDynamicRenderer() {\n    const vcr = inject(ViewContainerRef);\n    const parent = inject(Injector);\n    inject(DestroyRef).onDestroy(() => {\n        vcr.clear();\n    });\n    let lastComponent = null;\n    let lastKey = null;\n    const clear = () => {\n        if (lastComponent)\n            vcr.clear();\n        lastComponent = null;\n        lastKey = null;\n    };\n    return {\n        clear,\n        render: ({ component, providers = [], key, inputs }) => {\n            if (lastComponent === component && lastKey === key) {\n                return;\n            }\n            vcr.clear();\n            if (!component)\n                return;\n            const injector = Injector.create({ providers, parent });\n            const bindings = Object.entries(inputs ?? {}).map(([name, value]) => inputBinding(name, value));\n            const cmpRef = vcr.createComponent(component, { injector, bindings });\n            cmpRef.changeDetectorRef.markForCheck();\n            lastComponent = component;\n            lastKey = key ?? null;\n        },\n    };\n}\n\nclass DefaultNotFoundComponent {\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.4\", ngImport: i0, type: DefaultNotFoundComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }\n    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"21.0.4\", type: DefaultNotFoundComponent, isStandalone: true, selector: \"ng-component\", host: { styleAttribute: \"display: contents;\" }, ngImport: i0, template: `<p>Not found</p>`, isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.4\", ngImport: i0, type: DefaultNotFoundComponent, decorators: [{\n            type: Component,\n            args: [{\n                    template: `<p>Not found</p>`,\n                    changeDetection: ChangeDetectionStrategy.OnPush,\n                    host: { style: 'display: contents;' },\n                }]\n        }] });\n\n// In Angular, there is not concept of suspense or error boundaries,\n// so we dont' need to wrap the inner content of the match.\n// So in this adapter, we use derived state instead of state boundaries.\n// Equivalent to the OnRendered component.\nfunction injectOnRendered({ parentRouteId, rootRouteId, }) {\n    const router = injectRouter({ warn: false });\n    const location = injectRouterState({\n        select: (s) => s.resolvedLocation?.state.key,\n    });\n    const isRootRoute = computed(() => parentRouteId() === rootRouteId(), ...(ngDevMode ? [{ debugName: \"isRootRoute\" }] : []));\n    effect(() => {\n        if (!isRootRoute())\n            return;\n        location(); // Track location\n        router.emit({\n            type: 'onRendered',\n            ...getLocationChangeInfo(router.state),\n        });\n    });\n}\nclass RouteMatch {\n    constructor() {\n        this.matchId = input.required(...(ngDevMode ? [{ debugName: \"matchId\" }] : []));\n        this.router = injectRouter();\n        this.matchData = injectRouterState({\n            select: (s) => {\n                const matchIndex = s.matches.findIndex((d) => d.id === this.matchId());\n                if (matchIndex === -1)\n                    return null;\n                const match = s.matches[matchIndex];\n                const parentRouteId = matchIndex > 0 ? s.matches[matchIndex - 1]?.routeId : null;\n                const routeId = match.routeId;\n                const route = this.router.routesById[routeId];\n                const remountFn = route.options.remountDeps ?? this.router.options.defaultRemountDeps;\n                const remountDeps = remountFn?.({\n                    routeId,\n                    loaderDeps: match.loaderDeps,\n                    params: match._strictParams,\n                    search: match._strictSearch,\n                });\n                const key = remountDeps ? JSON.stringify(remountDeps) : undefined;\n                return {\n                    key,\n                    route,\n                    match,\n                    parentRouteId,\n                };\n            },\n        });\n        this.isFistRouteInRouteTree = computed(() => this.matchData()?.parentRouteId === rootRouteId, ...(ngDevMode ? [{ debugName: \"isFistRouteInRouteTree\" }] : []));\n        this.resolvedNoSsr = computed(() => {\n            const match = this.matchData()?.match;\n            if (!match)\n                return true;\n            return match.ssr === false || match.ssr === 'data-only';\n        }, ...(ngDevMode ? [{ debugName: \"resolvedNoSsr\" }] : []));\n        this.shouldClientOnly = computed(() => {\n            const match = this.matchData()?.match;\n            if (!match)\n                return true;\n            return this.resolvedNoSsr() || !!match._displayPending;\n        }, ...(ngDevMode ? [{ debugName: \"shouldClientOnly\" }] : []));\n        this.rendering = injectDynamicRenderer();\n        this.render = effect(() => {\n            const matchData = this.matchData();\n            if (!matchData)\n                return;\n            if (this.shouldClientOnly() && this.router.isServer) {\n                this.rendering.clear();\n                return;\n            }\n            const { match, route } = matchData;\n            if (match.status === 'notFound') {\n                const NotFoundComponent = getNotFoundComponent(this.router, route);\n                this.rendering.render({ component: NotFoundComponent });\n            }\n            else if (match.status === 'error') {\n                const RouteErrorComponent = route.options.errorComponent ??\n                    this.router.options.defaultErrorComponent;\n                this.rendering.render({\n                    component: RouteErrorComponent || null,\n                    inputs: {\n                        error: () => match.error,\n                        reset: () => {\n                            this.router.invalidate();\n                        },\n                        info: () => {\n                            return { componentStack: '' };\n                        },\n                    },\n                });\n            }\n            else if (match._forcePending ||\n                match._displayPending ||\n                match.status === 'redirected' ||\n                match.status === 'pending') {\n                const pendingMinMs = route.options.pendingMinMs ?? this.router.options.defaultPendingMinMs;\n                // If the compoennt is pending and has a minPendingMs,\n                // we create a promise that will be awaited in the route core\n                // to ensure that the pending state is displayed for that amount of time\n                if (match.status === 'pending' &&\n                    pendingMinMs &&\n                    !match._nonReactive.minPendingPromise &&\n                    !this.router.isServer) {\n                    const minPendingPromise = createControlledPromise();\n                    match._nonReactive.minPendingPromise = minPendingPromise;\n                    setTimeout(() => {\n                        minPendingPromise.resolve();\n                        match._nonReactive.minPendingPromise = undefined;\n                    }, pendingMinMs);\n                }\n                const PendingComponent = route.options.pendingComponent ??\n                    this.router.options.defaultPendingComponent;\n                this.rendering.render({ component: PendingComponent });\n            }\n            else if (match.status === 'success') {\n                const Component = route.options.component ??\n                    this.router.options.defaultComponent ??\n                    Outlet;\n                const key = matchData.key;\n                const matchIdSignal = computed(() => this.matchId());\n                this.rendering.render({\n                    key,\n                    component: Component,\n                    providers: [\n                        {\n                            provide: MATCH_ID_INJECTOR_TOKEN,\n                            useValue: matchIdSignal,\n                        },\n                    ],\n                });\n            }\n        }, ...(ngDevMode ? [{ debugName: \"render\" }] : []));\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.4\", ngImport: i0, type: RouteMatch, deps: [], target: i0.ɵɵFactoryTarget.Component }); }\n    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"17.1.0\", version: \"21.0.4\", type: RouteMatch, isStandalone: true, selector: \"router-match\", inputs: { matchId: { classPropertyName: \"matchId\", publicName: \"matchId\", isSignal: true, isRequired: true, transformFunction: null } }, host: { properties: { \"attr.data-matchId\": \"matchId()\" } }, ngImport: i0, template: '', isInline: true }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.4\", ngImport: i0, type: RouteMatch, decorators: [{\n            type: Component,\n            args: [{\n                    selector: 'router-match',\n                    template: '',\n                    standalone: true,\n                    host: {\n                        '[attr.data-matchId]': 'matchId()',\n                    },\n                }]\n        }], propDecorators: { matchId: [{ type: i0.Input, args: [{ isSignal: true, alias: \"matchId\", required: true }] }] } });\nclass Outlet {\n    constructor() {\n        this.router = injectRouter();\n        this.matchId = inject(MATCH_ID_INJECTOR_TOKEN);\n        this.routeId = injectRouterState({\n            select: (s) => s.matches.find((d) => d.id === this.matchId())?.routeId,\n        });\n        this.route = computed(() => this.router.routesById[this.routeId()], ...(ngDevMode ? [{ debugName: \"route\" }] : []));\n        this.parentGlobalNotFound = injectRouterState({\n            select: (s) => {\n                const matches = s.matches;\n                const parentMatch = matches.find((d) => d.id === this.matchId());\n                if (!parentMatch)\n                    return false;\n                return parentMatch.globalNotFound;\n            },\n        });\n        this.childMatchId = injectRouterState({\n            select: (s) => {\n                const matches = s.matches;\n                const index = matches.findIndex((d) => d.id === this.matchId());\n                const child = matches[index + 1];\n                if (!child)\n                    return null;\n                return child.id;\n            },\n        });\n        this.rendering = injectDynamicRenderer();\n        this.render = effect(() => {\n            if (this.parentGlobalNotFound()) {\n                // Render not found with warning\n                const NotFoundComponent = getNotFoundComponent(this.router, this.route());\n                this.rendering.render({ component: NotFoundComponent });\n                return;\n            }\n            const childMatchId = this.childMatchId();\n            if (!childMatchId) {\n                // Do not render anything\n                this.rendering.clear();\n                return;\n            }\n            this.rendering.render({\n                component: RouteMatch,\n                inputs: {\n                    matchId: () => this.childMatchId(),\n                },\n            });\n        }, ...(ngDevMode ? [{ debugName: \"render\" }] : []));\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.4\", ngImport: i0, type: Outlet, deps: [], target: i0.ɵɵFactoryTarget.Component }); }\n    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"21.0.4\", type: Outlet, isStandalone: true, selector: \"outlet\", ngImport: i0, template: '', isInline: true }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.4\", ngImport: i0, type: Outlet, decorators: [{\n            type: Component,\n            args: [{\n                    selector: 'outlet',\n                    template: '',\n                    standalone: true,\n                }]\n        }] });\nfunction getNotFoundComponent(router, route) {\n    let NotFoundComponent = route.options.notFoundComponent ?? router.options.defaultNotFoundComponent;\n    if (NotFoundComponent) {\n        return NotFoundComponent;\n    }\n    if (process.env.NODE_ENV === 'development') {\n        warning(route.options.notFoundComponent, `A notFoundError was encountered on the route with ID \"${route.id}\", but a notFoundComponent option was not configured, nor was a router level defaultNotFoundComponent configured. Consider configuring at least one of these to avoid TanStack Router's overly generic defaultNotFoundComponent (<p>Page not found</p>)`);\n    }\n    return DefaultNotFoundComponent;\n}\n\n// Track mount state per router to avoid double-loading\nlet mountLoadForRouter = {\n    router: null,\n    mounted: false,\n};\n/**\n * Helper function that sets up router transition logic.\n * This should be called from Matches component to set up:\n * - router.startTransition\n * - router.startViewTransition\n * - History subscription\n * - Router event watchers\n *\n * Must be called during component initialization.\n */\nfunction injectTransitionerSetup() {\n    const router = injectRouter();\n    // Skip on server - no transitions needed\n    if (router.isServer) {\n        return;\n    }\n    const destroyRef = inject(DestroyRef);\n    const isLoading = injectRouterState({\n        select: (s) => s.isLoading,\n    });\n    // Track if we're in a transition\n    const isTransitioning = signal(false, ...(ngDevMode ? [{ debugName: \"isTransitioning\" }] : []));\n    // Track pending state changes\n    const hasPendingMatches = injectRouterState({\n        select: (s) => s.matches.some((d) => d.status === 'pending'),\n    });\n    // Track previous values for comparison\n    let previousIsLoading;\n    let previousIsAnyPending;\n    let previousIsPagePending;\n    const isAnyPending = computed(() => isLoading() || isTransitioning() || hasPendingMatches(), ...(ngDevMode ? [{ debugName: \"isAnyPending\" }] : []));\n    const isPagePending = computed(() => isLoading() || hasPendingMatches(), ...(ngDevMode ? [{ debugName: \"isPagePending\" }] : []));\n    // Implement startTransition similar to React/Solid\n    // Angular doesn't have a native startTransition like React 18, so we simulate it\n    router.startTransition = (fn) => {\n        isTransitioning.set(true);\n        // Also update the router state so useMatch can check it\n        try {\n            router.__store.setState((s) => ({ ...s, isTransitioning: true }));\n        }\n        catch {\n            // Ignore errors if component is unmounted\n        }\n        // Execute the function\n        const result = fn();\n        // Handle async functions\n        if (result instanceof Promise) {\n            result\n                .then(() => {\n                isTransitioning.set(false);\n                try {\n                    router.__store.setState((s) => ({ ...s, isTransitioning: false }));\n                }\n                catch {\n                    // Ignore errors if component is unmounted\n                }\n            })\n                .catch(() => {\n                isTransitioning.set(false);\n                try {\n                    router.__store.setState((s) => ({ ...s, isTransitioning: false }));\n                }\n                catch {\n                    // Ignore errors if component is unmounted\n                }\n            });\n        }\n        else {\n            // For sync functions, use setTimeout to allow Angular to process updates\n            setTimeout(() => {\n                isTransitioning.set(false);\n                try {\n                    router.__store.setState((s) => ({ ...s, isTransitioning: false }));\n                }\n                catch {\n                    // Ignore errors if component is unmounted\n                }\n            }, 0);\n        }\n    };\n    // Angular doesn't have View Transitions API support like Vue, but we can still\n    // set up the function for compatibility\n    const originalStartViewTransition = router.__tsrOriginalStartViewTransition ??\n        router.startViewTransition;\n    router.__tsrOriginalStartViewTransition =\n        originalStartViewTransition;\n    router.startViewTransition = (fn) => {\n        return originalStartViewTransition?.(fn);\n    };\n    // Subscribe to location changes and try to load the new location\n    let unsubscribe;\n    afterNextRender(() => {\n        unsubscribe = router.history.subscribe(router.load);\n        const nextLocation = router.buildLocation({\n            to: router.latestLocation.pathname,\n            search: true,\n            params: true,\n            hash: true,\n            state: true,\n            _includeValidateSearch: true,\n        });\n        if (trimPathRight(router.latestLocation.href) !==\n            trimPathRight(nextLocation.href)) {\n            router.commitLocation({ ...nextLocation, replace: true });\n        }\n    });\n    // Track if component is mounted to prevent updates after unmount\n    const isMounted = signal(false, ...(ngDevMode ? [{ debugName: \"isMounted\" }] : []));\n    afterNextRender(() => {\n        isMounted.set(true);\n        if (!isAnyPending()) {\n            router.__store.setState((s) => s.status === 'pending'\n                ? { ...s, status: 'idle', resolvedLocation: s.location }\n                : s);\n        }\n    });\n    destroyRef.onDestroy(() => {\n        isMounted.set(false);\n        if (unsubscribe) {\n            unsubscribe();\n        }\n    });\n    // Try to load the initial location\n    afterNextRender(() => {\n        if ((typeof window !== 'undefined' && router.ssr) ||\n            (mountLoadForRouter.router === router && mountLoadForRouter.mounted)) {\n            return;\n        }\n        mountLoadForRouter = { router, mounted: true };\n        const tryLoad = async () => {\n            try {\n                await router.load();\n            }\n            catch (err) {\n                console.error(err);\n            }\n        };\n        tryLoad();\n    });\n    // Setup effects for emitting events\n    // All effects check isMounted to prevent updates after unmount\n    // Watch for onLoad event\n    effect(() => {\n        if (!isMounted())\n            return;\n        const currentIsLoading = isLoading();\n        try {\n            if (previousIsLoading && !currentIsLoading) {\n                router.emit({\n                    type: 'onLoad',\n                    ...getLocationChangeInfo(router.state),\n                });\n            }\n            previousIsLoading = currentIsLoading;\n        }\n        catch {\n            // Ignore errors if component is unmounted\n        }\n    });\n    // Watch for onBeforeRouteMount event\n    effect(() => {\n        if (!isMounted())\n            return;\n        const currentIsPagePending = isPagePending();\n        try {\n            if (previousIsPagePending && !currentIsPagePending) {\n                router.emit({\n                    type: 'onBeforeRouteMount',\n                    ...getLocationChangeInfo(router.state),\n                });\n            }\n            previousIsPagePending = currentIsPagePending;\n        }\n        catch {\n            // Ignore errors if component is unmounted\n        }\n    });\n    // Watch for onResolved event\n    effect(() => {\n        if (!isMounted())\n            return;\n        const currentIsAnyPending = isAnyPending();\n        try {\n            if (!currentIsAnyPending && router.__store.state.status === 'pending') {\n                router.__store.setState((s) => ({\n                    ...s,\n                    status: 'idle',\n                    resolvedLocation: s.location,\n                }));\n            }\n            // The router was pending and now it's not\n            if (previousIsAnyPending && !currentIsAnyPending) {\n                const changeInfo = getLocationChangeInfo(router.state);\n                router.emit({\n                    type: 'onResolved',\n                    ...changeInfo,\n                });\n                if (changeInfo.hrefChanged) {\n                    handleHashScroll(router);\n                }\n            }\n            previousIsAnyPending = currentIsAnyPending;\n        }\n        catch {\n            // Ignore errors if component is unmounted\n        }\n    });\n}\n\nclass Matches {\n    constructor() {\n        this.matchId = injectRouterState({\n            select: (s) => s.matches[0]?.id,\n        });\n        this.renderer = injectDynamicRenderer();\n        this.transitioner = injectTransitionerSetup();\n        this.render = effect(() => {\n            const matchId = this.matchId();\n            if (!matchId) {\n                this.renderer.clear();\n                return;\n            }\n            this.renderer.render({\n                component: RouteMatch,\n                inputs: {\n                    matchId: () => matchId,\n                },\n            });\n        }, ...(ngDevMode ? [{ debugName: \"render\" }] : []));\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.4\", ngImport: i0, type: Matches, deps: [], target: i0.ɵɵFactoryTarget.Component }); }\n    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"21.0.4\", type: Matches, isStandalone: true, selector: \"router-matches\", ngImport: i0, template: '', isInline: true }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.4\", ngImport: i0, type: Matches, decorators: [{\n            type: Component,\n            args: [{ selector: 'router-matches', template: '', standalone: true }]\n        }] });\n\nclass RouterProvider {\n    constructor() {\n        this.router = input.required(...(ngDevMode ? [{ debugName: \"router\" }] : []));\n        this.renderer = injectDynamicRenderer();\n        this.render = effect(() => {\n            const router = untracked(this.router);\n            this.renderer.render({\n                component: Matches,\n                providers: [\n                    {\n                        provide: getRouterInjectionKey(),\n                        useValue: router,\n                    },\n                ],\n            });\n        }, ...(ngDevMode ? [{ debugName: \"render\" }] : []));\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.4\", ngImport: i0, type: RouterProvider, deps: [], target: i0.ɵɵFactoryTarget.Component }); }\n    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"17.1.0\", version: \"21.0.4\", type: RouterProvider, isStandalone: true, selector: \"router-provider\", inputs: { router: { classPropertyName: \"router\", publicName: \"router\", isSignal: true, isRequired: true, transformFunction: null } }, ngImport: i0, template: '', isInline: true }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.4\", ngImport: i0, type: RouterProvider, decorators: [{\n            type: Component,\n            args: [{ selector: 'router-provider', template: '', standalone: true }]\n        }], propDecorators: { router: [{ type: i0.Input, args: [{ isSignal: true, alias: \"router\", required: true }] }] } });\n\nfunction injectRouterContext(opts) {\n    return injectMatch({\n        ...opts,\n        select: (match) => opts.select ? opts.select(match.context) : match.context,\n    });\n}\n\nfunction injectLocation(opts) {\n    return injectRouterState({\n        select: (s) => (opts.select ? opts.select(s.location) : s.location),\n    });\n}\n\nfunction injectBlocker(opts) {\n    const shouldBlockFn = opts.shouldBlockFn;\n    const router = injectRouter();\n    const resolver = signal({\n        status: 'idle',\n        current: undefined,\n        next: undefined,\n        action: undefined,\n        proceed: undefined,\n        reset: undefined,\n    }, ...(ngDevMode ? [{ debugName: \"resolver\" }] : []));\n    effect((onCleanup) => {\n        const blockerFnComposed = async (blockerFnArgs) => {\n            function getLocation(location) {\n                const parsedLocation = router.parseLocation(location);\n                const matchedRoutes = router.getMatchedRoutes(parsedLocation.pathname);\n                if (matchedRoutes.foundRoute === undefined) {\n                    return {\n                        routeId: '__notFound__',\n                        fullPath: parsedLocation.pathname,\n                        pathname: parsedLocation.pathname,\n                        params: matchedRoutes.routeParams,\n                        search: parsedLocation.search,\n                    };\n                }\n                return {\n                    routeId: matchedRoutes.foundRoute.id,\n                    fullPath: matchedRoutes.foundRoute.fullPath,\n                    pathname: parsedLocation.pathname,\n                    params: matchedRoutes.routeParams,\n                    search: parsedLocation.search,\n                };\n            }\n            const current = getLocation(blockerFnArgs.currentLocation);\n            const next = getLocation(blockerFnArgs.nextLocation);\n            if (current.routeId === '__notFound__' &&\n                next.routeId !== '__notFound__') {\n                return false;\n            }\n            const shouldBlock = await shouldBlockFn({\n                action: blockerFnArgs.action,\n                current,\n                next,\n            });\n            if (!opts.withResolver) {\n                return shouldBlock;\n            }\n            if (!shouldBlock) {\n                return false;\n            }\n            const promise = new Promise((resolve) => {\n                resolver.set({\n                    status: 'blocked',\n                    current,\n                    next,\n                    action: blockerFnArgs.action,\n                    proceed: () => resolve(false),\n                    reset: () => resolve(true),\n                });\n            });\n            const canNavigateAsync = await promise;\n            resolver.set({\n                status: 'idle',\n                current: undefined,\n                next: undefined,\n                action: undefined,\n                proceed: undefined,\n                reset: undefined,\n            });\n            return canNavigateAsync;\n        };\n        const disposeBlock = opts.disabled\n            ? undefined\n            : router.history.block({\n                blockerFn: blockerFnComposed,\n                enableBeforeUnload: opts.enableBeforeUnload,\n            });\n        onCleanup(() => disposeBlock?.());\n    });\n    return resolver.asReadonly();\n}\n\nfunction injectCanGoBack() {\n    return injectRouterState({\n        select: (s) => s.location.state.__TSR_index !== 0,\n    });\n}\n\nfunction injectIntersectionObserver(callback, intersectionObserverOptions, disabled) {\n    const elementRef = inject(ElementRef);\n    afterRenderEffect((onCleanup) => {\n        const isDisabled = disabled();\n        const element = elementRef.nativeElement;\n        if (isDisabled || !element)\n            return;\n        const observer = new IntersectionObserver(([entry]) => callback(entry), intersectionObserverOptions);\n        observer.observe(element);\n        onCleanup(() => {\n            observer.disconnect();\n        });\n    });\n}\n\n// Router\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MATCH_ID_INJECTOR_TOKEN, Matches, NotFoundRoute, Outlet, RootRoute, Route, RouteApi, RouteMatch, RouterProvider, createRootRoute, createRootRouteWithContext, createRoute, createRouteMask, createRouter, getRouteApi, getRouterInjectionKey, injectBlocker, injectCanGoBack, injectDynamicRenderer, injectIntersectionObserver, injectLoaderData, injectLoaderDeps, injectLocation, injectMatch, injectNavigate, injectParams, injectRouter, injectRouterContext, injectRouterState, injectSearch, rootRouteWithContext };\n//# sourceMappingURL=tanstack-angular-router.mjs.map\n","map":null,"preliminaryFileName":"tanstack-angular-router.mjs","sourcemapFileName":"tanstack-angular-router.mjs.map"},{"fileName":"tanstack-angular-router.mjs.map","names":[],"needsCodeReference":false,"originalFileName":null,"originalFileNames":[],"source":"{\"version\":3,\"file\":\"tanstack-angular-router.mjs\",\"sources\":[\"../../src/router.ts\",\"../../src/matchInjectorToken.ts\",\"../../src/routerInjectionToken.ts\",\"../../src/injectRouter.ts\",\"../../src/injectRouterState.ts\",\"../../src/injectMatch.ts\",\"../../src/injectLoaderData.ts\",\"../../src/injectLoaderDeps.ts\",\"../../src/injectParams.ts\",\"../../src/injectSearch.ts\",\"../../src/injectNavigate.ts\",\"../../src/route.ts\",\"../../src/dynamicRenderer.ts\",\"../../src/DefaultNotFound.ts\",\"../../src/Match.ts\",\"../../src/transitioner.ts\",\"../../src/Macthes.ts\",\"../../src/RouterProvider.ts\",\"../../src/injectRouteContext.ts\",\"../../src/injectLocationResult.ts\",\"../../src/injectBlocker.ts\",\"../../src/injectCanGoBack.ts\",\"../../src/injectIntersectionObserver.ts\",\"../../src/index.ts\",\"../../src/tanstack-angular-router.ts\"],\"sourcesContent\":[\"import {\\n  AnyRoute,\\n  CreateRouterFn,\\n  RouterConstructorOptions,\\n  RouterCore,\\n  TrailingSlashOption,\\n} from '@tanstack/router-core'\\nimport { ErrorRouteComponent, RouteComponent } from './route'\\nimport { RouterHistory } from '@tanstack/history'\\n\\ndeclare module '@tanstack/router-core' {\\n  export interface RouterOptionsExtensions {\\n    /**\\n     * The default `component` a route should use if no component is provided.\\n     *\\n     * @default Outlet\\n     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/solid/api/router/RouterOptionsType#defaultcomponent-property)\\n     */\\n    defaultComponent?: RouteComponent\\n    /**\\n     * The default `errorComponent` a route should use if no error component is provided.\\n     *\\n     * @default ErrorComponent\\n     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/solid/api/router/RouterOptionsType#defaulterrorcomponent-property)\\n     * @link [Guide](https://tanstack.com/router/latest/docs/framework/solid/guide/data-loading#handling-errors-with-routeoptionserrorcomponent)\\n     */\\n    defaultErrorComponent?: ErrorRouteComponent\\n    /**\\n     * The default `pendingComponent` a route should use if no pending component is provided.\\n     *\\n     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/solid/api/router/RouterOptionsType#defaultpendingcomponent-property)\\n     * @link [Guide](https://tanstack.com/router/latest/docs/framework/solid/guide/data-loading#showing-a-pending-component)\\n     */\\n    defaultPendingComponent?: RouteComponent\\n    /**\\n     * The default `notFoundComponent` a route should use if no notFound component is provided.\\n     *\\n     * @default NotFound\\n     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/solid/api/router/RouterOptionsType#defaultnotfoundcomponent-property)\\n     * @link [Guide](https://tanstack.com/router/latest/docs/framework/solid/guide/not-found-errors#default-router-wide-not-found-handling)\\n     */\\n    defaultNotFoundComponent?: RouteComponent\\n  }\\n}\\n\\nexport const createRouter: CreateRouterFn = (options: any) => {\\n  return new Router(options)\\n}\\n\\nexport class Router<\\n  in out TRouteTree extends AnyRoute,\\n  in out TTrailingSlashOption extends TrailingSlashOption = 'never',\\n  in out TDefaultStructuralSharingOption extends boolean = false,\\n  in out TRouterHistory extends RouterHistory = RouterHistory,\\n  in out TDehydrated extends Record<string, any> = Record<string, any>,\\n> extends RouterCore<\\n  TRouteTree,\\n  TTrailingSlashOption,\\n  TDefaultStructuralSharingOption,\\n  TRouterHistory,\\n  TDehydrated\\n> {\\n  constructor(\\n    options: RouterConstructorOptions<\\n      TRouteTree,\\n      TTrailingSlashOption,\\n      TDefaultStructuralSharingOption,\\n      TRouterHistory,\\n      TDehydrated\\n    >,\\n  ) {\\n    super(options)\\n  }\\n}\\n\",\"import { InjectionToken, signal, Signal } from '@angular/core'\\n\\nexport const MATCH_ID_INJECTOR_TOKEN = new InjectionToken<\\n  Signal<string | undefined>\\n>('MATCH_ID_INJECTOR', {\\n  factory: () => signal(undefined),\\n})\\n\",\"import { InjectionToken } from '@angular/core'\\nimport type { AnyRouter } from '@tanstack/router-core'\\n\\ndeclare global {\\n  interface Window {\\n    __TSR_ROUTER_INJECTION_KEY__?: InjectionToken<AnyRouter>\\n  }\\n}\\n\\nconst routerInjectionKey = new InjectionToken<AnyRouter>('ROUTER')\\n\\nexport function getRouterInjectionKey() {\\n  if (typeof document === 'undefined') {\\n    return routerInjectionKey\\n  }\\n\\n  if (window.__TSR_ROUTER_INJECTION_KEY__) {\\n    return window.__TSR_ROUTER_INJECTION_KEY__\\n  }\\n\\n  window.__TSR_ROUTER_INJECTION_KEY__ = routerInjectionKey as any\\n\\n  return routerInjectionKey\\n}\\n\",\"import { getRouterInjectionKey } from './routerInjectionToken'\\nimport { inject } from '@angular/core'\\nimport warning from 'tiny-warning'\\nimport type { AnyRouter, RegisteredRouter } from '@tanstack/router-core'\\n\\nexport function injectRouter<\\n  TRouter extends AnyRouter = RegisteredRouter,\\n>(opts?: { warn?: boolean }): TRouter {\\n  const router = inject(getRouterInjectionKey(), { optional: true })\\n  warning(\\n    !((opts?.warn ?? true) && !router),\\n    'No router found in the injector contetext for injectRouter!',\\n  )\\n  return router as any\\n}\\n\\nexport type InjectRouterResult<TRouter extends AnyRouter = RegisteredRouter> =\\n  TRouter\\n\",\"import { injectStore } from '@tanstack/angular-store'\\nimport type {\\n  AnyRouter,\\n  RegisteredRouter,\\n  RouterState,\\n} from '@tanstack/router-core'\\nimport { injectRouter } from './injectRouter'\\nimport { Signal } from '@angular/core'\\n\\nexport type InjectRouterStateOptions<TRouter extends AnyRouter, TSelected> = {\\n  router?: TRouter\\n  select?: (state: RouterState<TRouter['routeTree']>) => TSelected\\n}\\n\\nexport type InjectRouterStateResult<\\n  TRouter extends AnyRouter,\\n  TSelected,\\n> = unknown extends TSelected ? RouterState<TRouter['routeTree']> : TSelected\\n\\nexport function injectRouterState<\\n  TRouter extends AnyRouter = RegisteredRouter,\\n  TSelected = unknown,\\n>(\\n  opts?: InjectRouterStateOptions<TRouter, TSelected>,\\n): Signal<InjectRouterStateResult<TRouter, TSelected>> {\\n  const contextRouter = injectRouter({\\n    warn: opts?.router === undefined,\\n  })\\n\\n  const router = opts?.router ?? contextRouter\\n\\n  return injectStore(router.__store, (state) => {\\n    if (opts?.select) return opts.select(state)\\n\\n    return state\\n  }) as Signal<InjectRouterStateResult<TRouter, TSelected>>\\n}\\n\",\"import { computed, inject, Signal } from '@angular/core'\\nimport { MATCH_ID_INJECTOR_TOKEN } from './matchInjectorToken'\\nimport { injectRouterState } from './injectRouterState'\\nimport {\\n  AnyRouter,\\n  MakeRouteMatch,\\n  MakeRouteMatchUnion,\\n  RegisteredRouter,\\n  StrictOrFrom,\\n  ThrowConstraint,\\n  ThrowOrOptional,\\n} from '@tanstack/router-core'\\n\\nexport interface InjectMatchBaseOptions<\\n  TRouter extends AnyRouter,\\n  TFrom,\\n  TStrict extends boolean,\\n  TThrow extends boolean,\\n  TSelected,\\n> {\\n  select?: (\\n    match: MakeRouteMatch<TRouter['routeTree'], TFrom, TStrict>,\\n  ) => TSelected\\n  shouldThrow?: TThrow\\n}\\n\\nexport type InjectMatchOptions<\\n  TRouter extends AnyRouter,\\n  TFrom,\\n  TStrict extends boolean,\\n  TThrow extends boolean,\\n  TSelected,\\n> = StrictOrFrom<TRouter, TFrom, TStrict> &\\n  InjectMatchBaseOptions<TRouter, TFrom, TStrict, TThrow, TSelected>\\n\\nexport type InjectMatchResult<\\n  TRouter extends AnyRouter,\\n  TFrom,\\n  TStrict extends boolean,\\n  TSelected,\\n> = unknown extends TSelected\\n  ? TStrict extends true\\n    ? MakeRouteMatch<TRouter['routeTree'], TFrom, TStrict>\\n    : MakeRouteMatchUnion<TRouter>\\n  : TSelected\\n\\nexport type InjectMatchRoute<out TFrom> = <\\n  TRouter extends AnyRouter = RegisteredRouter,\\n  TSelected = unknown,\\n>(\\n  opts?: InjectMatchBaseOptions<TRouter, TFrom, true, true, TSelected>,\\n) => Signal<InjectMatchResult<TRouter, TFrom, true, TSelected>>\\n\\nexport function injectMatch<\\n  TRouter extends AnyRouter = RegisteredRouter,\\n  const TFrom extends string | undefined = undefined,\\n  TStrict extends boolean = true,\\n  TThrow extends boolean = true,\\n  TSelected = unknown,\\n>(\\n  opts: InjectMatchOptions<\\n    TRouter,\\n    TFrom,\\n    TStrict,\\n    ThrowConstraint<TStrict, TThrow>,\\n    TSelected\\n  >,\\n): Signal<\\n  ThrowOrOptional<InjectMatchResult<TRouter, TFrom, TStrict, TSelected>, TThrow>\\n> {\\n  const nearestMatchId = inject(MATCH_ID_INJECTOR_TOKEN)\\n\\n  const matchState = injectRouterState({\\n    select: (state) => {\\n      const match = state.matches.find((d) =>\\n        opts.from ? opts.from === d.routeId : d.id === nearestMatchId(),\\n      )\\n\\n      if (match === undefined) {\\n        // During navigation transitions, check if the match exists in pendingMatches\\n        const pendingMatch = state.pendingMatches?.find((d) =>\\n          opts.from ? opts.from === d.routeId : d.id === nearestMatchId(),\\n        )\\n\\n        // Determine if we should throw an error\\n        const shouldThrowError =\\n          !pendingMatch && !state.isTransitioning && (opts.shouldThrow ?? true)\\n\\n        return {\\n          match: undefined,\\n          shouldThrowError,\\n        } as const\\n      }\\n\\n      return {\\n        match: opts.select ? opts.select(match) : match,\\n        shouldThrowError: false,\\n      } as const\\n    },\\n  })\\n\\n  // Throw the error if we have one - this happens after the selector runs\\n  // Using a computed so the error is thrown when the return value is accessed\\n  return computed(() => {\\n    const state = matchState()\\n    if (state.shouldThrowError) {\\n      throw new Error(\\n        `Could not find ${opts.from ? `an active match from \\\"${opts.from}\\\"` : 'a nearest match!'}`,\\n      )\\n    }\\n    return state.match as any\\n  })\\n}\\n\",\"import { Signal } from '@angular/core'\\nimport {\\n  AnyRouter,\\n  RegisteredRouter,\\n  ResolveUseLoaderData,\\n  StrictOrFrom,\\n  UseLoaderDataResult,\\n} from '@tanstack/router-core'\\nimport { injectMatch } from './injectMatch'\\n\\nexport interface InjectLoaderDataBaseOptions<\\n  TRouter extends AnyRouter,\\n  TFrom,\\n  TStrict extends boolean,\\n  TSelected,\\n> {\\n  select?: (match: ResolveUseLoaderData<TRouter, TFrom, TStrict>) => TSelected\\n}\\n\\nexport type InjectLoaderDataOptions<\\n  TRouter extends AnyRouter,\\n  TFrom extends string | undefined,\\n  TStrict extends boolean,\\n  TSelected,\\n> = StrictOrFrom<TRouter, TFrom, TStrict> &\\n  InjectLoaderDataBaseOptions<TRouter, TFrom, TStrict, TSelected>\\n\\nexport type InjectLoaderDataRoute<out TFrom> = <\\n  TRouter extends AnyRouter = RegisteredRouter,\\n  TSelected = unknown,\\n>(\\n  opts?: InjectLoaderDataBaseOptions<TRouter, TFrom, true, TSelected>,\\n) => Signal<UseLoaderDataResult<TRouter, TFrom, true, TSelected>>\\n\\nexport function injectLoaderData<\\n  TRouter extends AnyRouter = RegisteredRouter,\\n  const TFrom extends string | undefined = undefined,\\n  TStrict extends boolean = true,\\n  TSelected = unknown,\\n>(\\n  opts: InjectLoaderDataOptions<TRouter, TFrom, TStrict, TSelected>,\\n): Signal<UseLoaderDataResult<TRouter, TFrom, TStrict, TSelected>> {\\n  return injectMatch({\\n    from: opts.from!,\\n    strict: opts.strict as true | undefined,\\n    select: (s: any) =>\\n      opts.select ? opts.select(s.loaderData) : s.loaderData,\\n  } as any) as any\\n}\\n\",\"import { Signal } from '@angular/core'\\nimport {\\n  AnyRouter,\\n  RegisteredRouter,\\n  ResolveUseLoaderDeps,\\n  StrictOrFrom,\\n  UseLoaderDepsResult,\\n} from '@tanstack/router-core'\\nimport { injectMatch } from './injectMatch'\\n\\nexport interface InjectLoaderDepsBaseOptions<\\n  TRouter extends AnyRouter,\\n  TFrom,\\n  TSelected,\\n> {\\n  select?: (deps: ResolveUseLoaderDeps<TRouter, TFrom>) => TSelected\\n}\\n\\nexport type InjectLoaderDepsOptions<\\n  TRouter extends AnyRouter,\\n  TFrom extends string | undefined,\\n  TSelected,\\n> = StrictOrFrom<TRouter, TFrom> &\\n  InjectLoaderDepsBaseOptions<TRouter, TFrom, TSelected>\\n\\nexport type InjectLoaderDepsRoute<out TFrom> = <\\n  TRouter extends AnyRouter = RegisteredRouter,\\n  TSelected = unknown,\\n>(\\n  opts?: InjectLoaderDepsBaseOptions<TRouter, TFrom, TSelected>,\\n) => Signal<UseLoaderDepsResult<TRouter, TFrom, TSelected>>\\n\\nexport function injectLoaderDeps<\\n  TRouter extends AnyRouter = RegisteredRouter,\\n  const TFrom extends string | undefined = undefined,\\n  TSelected = unknown,\\n>(\\n  opts: InjectLoaderDepsOptions<TRouter, TFrom, TSelected>,\\n): Signal<UseLoaderDepsResult<TRouter, TFrom, TSelected>> {\\n  const { select, ...rest } = opts\\n  return injectMatch({\\n    ...rest,\\n    select: (s) => (select ? select(s.loaderDeps) : s.loaderDeps),\\n  }) as any\\n}\\n\",\"import { injectMatch } from './injectMatch'\\nimport type { Signal } from '@angular/core'\\nimport type {\\n  AnyRouter,\\n  RegisteredRouter,\\n  ResolveUseParams,\\n  StrictOrFrom,\\n  ThrowConstraint,\\n  ThrowOrOptional,\\n  UseParamsResult,\\n} from '@tanstack/router-core'\\n\\nexport interface InjectParamsBaseOptions<\\n  TRouter extends AnyRouter,\\n  TFrom,\\n  TStrict extends boolean,\\n  TThrow extends boolean,\\n  TSelected,\\n> {\\n  select?: (params: ResolveUseParams<TRouter, TFrom, TStrict>) => TSelected\\n  shouldThrow?: TThrow\\n}\\n\\nexport type InjectParamsOptions<\\n  TRouter extends AnyRouter,\\n  TFrom extends string | undefined,\\n  TStrict extends boolean,\\n  TThrow extends boolean,\\n  TSelected,\\n> = StrictOrFrom<TRouter, TFrom, TStrict> &\\n  InjectParamsBaseOptions<TRouter, TFrom, TStrict, TThrow, TSelected>\\n\\nexport type InjectParamsRoute<out TFrom> = <\\n  TRouter extends AnyRouter = RegisteredRouter,\\n  TSelected = unknown,\\n>(\\n  opts?: InjectParamsBaseOptions<\\n    TRouter,\\n    TFrom,\\n    /* TStrict */ true,\\n    /* TThrow */ true,\\n    TSelected\\n  >,\\n) => Signal<UseParamsResult<TRouter, TFrom, true, TSelected>>\\n\\nexport function injectParams<\\n  TRouter extends AnyRouter = RegisteredRouter,\\n  const TFrom extends string | undefined = undefined,\\n  TStrict extends boolean = true,\\n  TThrow extends boolean = true,\\n  TSelected = unknown,\\n>(\\n  opts: InjectParamsOptions<\\n    TRouter,\\n    TFrom,\\n    TStrict,\\n    ThrowConstraint<TStrict, TThrow>,\\n    TSelected\\n  >,\\n): Signal<\\n  ThrowOrOptional<UseParamsResult<TRouter, TFrom, true, TSelected>, TThrow>\\n> {\\n  return injectMatch({\\n    from: opts.from!,\\n    strict: opts.strict as true | undefined,\\n    shouldThrow: opts.shouldThrow,\\n    select: (match: any) => {\\n      const params = opts.strict === false ? match.params : match._strictParams\\n\\n      return opts.select ? opts.select(params) : params\\n    },\\n  } as any) as Signal<any>\\n}\\n\",\"import { injectMatch } from './injectMatch'\\nimport type { Signal } from '@angular/core'\\nimport type {\\n  AnyRouter,\\n  RegisteredRouter,\\n  ResolveUseSearch,\\n  StrictOrFrom,\\n  ThrowConstraint,\\n  ThrowOrOptional,\\n  UseSearchResult,\\n} from '@tanstack/router-core'\\n\\nexport interface InjectSearchBaseOptions<\\n  TRouter extends AnyRouter,\\n  TFrom,\\n  TStrict extends boolean,\\n  TThrow extends boolean,\\n  TSelected,\\n> {\\n  select?: (state: ResolveUseSearch<TRouter, TFrom, TStrict>) => TSelected\\n  shouldThrow?: TThrow\\n}\\n\\nexport type InjectSearchOptions<\\n  TRouter extends AnyRouter,\\n  TFrom,\\n  TStrict extends boolean,\\n  TThrow extends boolean,\\n  TSelected,\\n> = StrictOrFrom<TRouter, TFrom, TStrict> &\\n  InjectSearchBaseOptions<TRouter, TFrom, TStrict, TThrow, TSelected>\\n\\nexport type InjectSearchRoute<out TFrom> = <\\n  TRouter extends AnyRouter = RegisteredRouter,\\n  TSelected = unknown,\\n>(\\n  opts?: InjectSearchBaseOptions<\\n    TRouter,\\n    TFrom,\\n    /* TStrict */ true,\\n    /* TThrow */ true,\\n    TSelected\\n  >,\\n) => Signal<UseSearchResult<TRouter, TFrom, true, TSelected>>\\n\\nexport function injectSearch<\\n  TRouter extends AnyRouter = RegisteredRouter,\\n  const TFrom extends string | undefined = undefined,\\n  TStrict extends boolean = true,\\n  TThrow extends boolean = true,\\n  TSelected = unknown,\\n>(\\n  opts: InjectSearchOptions<\\n    TRouter,\\n    TFrom,\\n    TStrict,\\n    ThrowConstraint<TStrict, TThrow>,\\n    TSelected\\n  >,\\n): Signal<\\n  ThrowOrOptional<UseSearchResult<TRouter, TFrom, TStrict, TSelected>, TThrow>\\n> {\\n  return injectMatch({\\n    from: opts.from!,\\n    strict: opts.strict,\\n    shouldThrow: opts.shouldThrow,\\n    select: (match: any) => {\\n      return opts.select ? opts.select(match.search) : match.search\\n    },\\n  } as any) as any\\n}\\n\",\"import type {\\n  AnyRouter,\\n  FromPathOption,\\n  NavigateOptions,\\n  RegisteredRouter,\\n  UseNavigateResult,\\n} from '@tanstack/router-core'\\nimport { injectRouter } from './injectRouter'\\n\\nexport function injectNavigate<\\n  TRouter extends AnyRouter = RegisteredRouter,\\n  TDefaultFrom extends string = string,\\n>(_defaultOpts?: {\\n  from?: FromPathOption<TRouter, TDefaultFrom>\\n}): UseNavigateResult<TDefaultFrom> {\\n  const router = injectRouter()\\n\\n  return ((options: NavigateOptions) => {\\n    return router.navigate({\\n      ...options,\\n      from: options.from ?? _defaultOpts?.from,\\n    })\\n  }) as UseNavigateResult<TDefaultFrom>\\n}\\n\\nexport type InjectNavigateResult<\\n  TRouter extends AnyRouter = RegisteredRouter,\\n  TDefaultFrom extends string = string,\\n> = UseNavigateResult<TDefaultFrom>\\n\",\"import {\\n  BaseRootRoute,\\n  BaseRoute,\\n  BaseRouteApi,\\n  notFound,\\n} from '@tanstack/router-core'\\nimport { injectLoaderData } from './injectLoaderData'\\nimport { injectLoaderDeps } from './injectLoaderDeps'\\nimport { injectParams } from './injectParams'\\nimport { injectSearch } from './injectSearch'\\nimport { injectNavigate } from './injectNavigate'\\nimport { injectMatch } from './injectMatch'\\nimport { injectRouter } from './injectRouter'\\nimport type {\\n  AnyContext,\\n  AnyRoute,\\n  AnyRouter,\\n  ConstrainLiteral,\\n  NotFoundError,\\n  Register,\\n  RegisteredRouter,\\n  ResolveFullPath,\\n  ResolveId,\\n  ResolveParams,\\n  RootRoute as RootRouteCore,\\n  RootRouteId,\\n  RootRouteOptions,\\n  RouteConstraints,\\n  Route as RouteCore,\\n  RouteIds,\\n  RouteMask,\\n  RouteOptions,\\n  RouteTypesById,\\n  RouterCore,\\n  ToMaskOptions,\\n  UseNavigateResult,\\n} from '@tanstack/router-core'\\nimport type { InjectLoaderDataRoute } from './injectLoaderData'\\nimport type { InjectMatchRoute } from './injectMatch'\\nimport type { InjectLoaderDepsRoute } from './injectLoaderDeps'\\nimport type { InjectParamsRoute } from './injectParams'\\nimport type { InjectSearchRoute } from './injectSearch'\\nimport type { InjectRouteContextRoute } from './injectRouteContext'\\nimport type { Type } from '@angular/core'\\n\\ndeclare module '@tanstack/router-core' {\\n  export interface UpdatableRouteOptionsExtensions {\\n    component?: RouteComponent\\n    errorComponent?: false | null | undefined | ErrorRouteComponent\\n    notFoundComponent?: NotFoundRouteComponent\\n    pendingComponent?: RouteComponent\\n  }\\n\\n  export interface RootRouteOptionsExtensions {\\n    shellComponent?: Type<{\\n      children: any\\n    }>\\n  }\\n\\n  export interface RouteExtensions<\\n    in out TId extends string,\\n    in out TFullPath extends string,\\n  > {\\n    injectMatch: InjectMatchRoute<TId>\\n    injectRouteContext: InjectRouteContextRoute<TId>\\n    injectSearch: InjectSearchRoute<TId>\\n    injectParams: InjectParamsRoute<TId>\\n    injectLoaderDeps: InjectLoaderDepsRoute<TId>\\n    injectLoaderData: InjectLoaderDataRoute<TId>\\n    injectNavigate: () => UseNavigateResult<TFullPath>\\n  }\\n}\\n\\nexport function getRouteApi<\\n  const TId,\\n  TRouter extends AnyRouter = RegisteredRouter,\\n>(id: ConstrainLiteral<TId, RouteIds<TRouter['routeTree']>>) {\\n  return new RouteApi<TId, TRouter>({ id })\\n}\\n\\nexport class RouteApi<\\n  TId,\\n  TRouter extends AnyRouter = RegisteredRouter,\\n> extends BaseRouteApi<TId, TRouter> {\\n  /**\\n   * @deprecated Use the `getRouteApi` function instead.\\n   */\\n  constructor({ id }: { id: TId }) {\\n    super({ id })\\n  }\\n\\n  injectMatch: InjectMatchRoute<TId> = (opts) => {\\n    return injectMatch({\\n      select: opts?.select,\\n      from: this.id,\\n    } as any) as any\\n  }\\n\\n  injectRouteContext: InjectRouteContextRoute<TId> = (opts) => {\\n    return injectMatch({\\n      from: this.id as any,\\n      select: (d) => (opts?.select ? opts.select(d.context) : d.context),\\n    }) as any\\n  }\\n\\n  injectSearch: InjectSearchRoute<TId> = (opts) => {\\n    return injectSearch({\\n      select: opts?.select,\\n      from: this.id,\\n    } as any) as any\\n  }\\n\\n  injectParams: InjectParamsRoute<TId> = (opts) => {\\n    return injectParams({\\n      select: opts?.select,\\n      from: this.id,\\n    } as any) as any\\n  }\\n\\n  injectLoaderDeps: InjectLoaderDepsRoute<TId> = (opts) => {\\n    return injectLoaderDeps({ ...opts, from: this.id, strict: false } as any)\\n  }\\n\\n  injectLoaderData: InjectLoaderDataRoute<TId> = (opts) => {\\n    return injectLoaderData({ ...opts, from: this.id, strict: false } as any)\\n  }\\n\\n  injectNavigate = (): UseNavigateResult<\\n    RouteTypesById<TRouter, TId>['fullPath']\\n  > => {\\n    const router = injectRouter()\\n    return injectNavigate({\\n      from: router.routesById[this.id as string].fullPath,\\n    })\\n  }\\n\\n  notFound = (opts?: NotFoundError) => {\\n    return notFound({ routeId: this.id as string, ...opts })\\n  }\\n}\\n\\nexport class Route<\\n    in out TRegister = unknown,\\n    in out TParentRoute extends RouteConstraints['TParentRoute'] = AnyRoute,\\n    in out TPath extends RouteConstraints['TPath'] = '/',\\n    in out TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<\\n      TParentRoute,\\n      TPath\\n    >,\\n    in out TCustomId extends RouteConstraints['TCustomId'] = string,\\n    in out TId extends RouteConstraints['TId'] = ResolveId<\\n      TParentRoute,\\n      TCustomId,\\n      TPath\\n    >,\\n    in out TSearchValidator = undefined,\\n    in out TParams = ResolveParams<TPath>,\\n    in out TRouterContext = AnyContext,\\n    in out TRouteContextFn = AnyContext,\\n    in out TBeforeLoadFn = AnyContext,\\n    in out TLoaderDeps extends Record<string, any> = {},\\n    in out TLoaderFn = undefined,\\n    in out TChildren = unknown,\\n    in out TFileRouteTypes = unknown,\\n    in out TSSR = unknown,\\n    in out TMiddlewares = unknown,\\n    in out THandlers = undefined,\\n  >\\n  extends BaseRoute<\\n    TRegister,\\n    TParentRoute,\\n    TPath,\\n    TFullPath,\\n    TCustomId,\\n    TId,\\n    TSearchValidator,\\n    TParams,\\n    TRouterContext,\\n    TRouteContextFn,\\n    TBeforeLoadFn,\\n    TLoaderDeps,\\n    TLoaderFn,\\n    TChildren,\\n    TFileRouteTypes,\\n    TSSR,\\n    TMiddlewares,\\n    THandlers\\n  >\\n  implements\\n    RouteCore<\\n      TRegister,\\n      TParentRoute,\\n      TPath,\\n      TFullPath,\\n      TCustomId,\\n      TId,\\n      TSearchValidator,\\n      TParams,\\n      TRouterContext,\\n      TRouteContextFn,\\n      TBeforeLoadFn,\\n      TLoaderDeps,\\n      TLoaderFn,\\n      TChildren,\\n      TFileRouteTypes,\\n      TSSR,\\n      TMiddlewares,\\n      THandlers\\n    >\\n{\\n  /**\\n   * @deprecated Use the `createRoute` function instead.\\n   */\\n  constructor(\\n    options?: RouteOptions<\\n      TRegister,\\n      TParentRoute,\\n      TId,\\n      TCustomId,\\n      TFullPath,\\n      TPath,\\n      TSearchValidator,\\n      TParams,\\n      TLoaderDeps,\\n      TLoaderFn,\\n      TRouterContext,\\n      TRouteContextFn,\\n      TBeforeLoadFn,\\n      TSSR,\\n      TMiddlewares,\\n      THandlers\\n    >,\\n  ) {\\n    super(options)\\n  }\\n\\n  injectMatch: InjectMatchRoute<TId> = (opts?: any) => {\\n    return injectMatch({\\n      select: opts?.select,\\n      from: this.id,\\n    } as any) as any\\n  }\\n\\n  injectRouteContext: InjectRouteContextRoute<TId> = (opts?: any) => {\\n    return injectMatch({\\n      ...opts,\\n      from: this.id,\\n      select: (d) => (opts?.select ? opts.select(d.context) : d.context),\\n    }) as any\\n  }\\n\\n  injectSearch: InjectSearchRoute<TId> = (opts) => {\\n    return injectSearch({\\n      select: opts?.select,\\n      from: this.id,\\n    } as any) as any\\n  }\\n\\n  injectParams: InjectParamsRoute<TId> = (opts) => {\\n    return injectParams({\\n      select: opts?.select,\\n      from: this.id,\\n    } as any) as any\\n  }\\n\\n  injectLoaderDeps: InjectLoaderDepsRoute<TId> = (opts) => {\\n    return injectLoaderDeps({ ...opts, from: this.id } as any)\\n  }\\n\\n  injectLoaderData: InjectLoaderDataRoute<TId> = (opts) => {\\n    return injectLoaderData({ ...opts, from: this.id } as any)\\n  }\\n\\n  injectNavigate = (): UseNavigateResult<TFullPath> => {\\n    return injectNavigate({ from: this.fullPath })\\n  }\\n}\\n\\nexport function createRoute<\\n  TRegister = unknown,\\n  TParentRoute extends RouteConstraints['TParentRoute'] = AnyRoute,\\n  TPath extends RouteConstraints['TPath'] = '/',\\n  TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<\\n    TParentRoute,\\n    TPath\\n  >,\\n  TCustomId extends RouteConstraints['TCustomId'] = string,\\n  TId extends RouteConstraints['TId'] = ResolveId<\\n    TParentRoute,\\n    TCustomId,\\n    TPath\\n  >,\\n  TSearchValidator = undefined,\\n  TParams = ResolveParams<TPath>,\\n  TRouteContextFn = AnyContext,\\n  TBeforeLoadFn = AnyContext,\\n  TLoaderDeps extends Record<string, any> = {},\\n  TLoaderFn = undefined,\\n  TChildren = unknown,\\n  TSSR = unknown,\\n  THandlers = undefined,\\n>(\\n  options: RouteOptions<\\n    TRegister,\\n    TParentRoute,\\n    TId,\\n    TCustomId,\\n    TFullPath,\\n    TPath,\\n    TSearchValidator,\\n    TParams,\\n    TLoaderDeps,\\n    TLoaderFn,\\n    AnyContext,\\n    TRouteContextFn,\\n    TBeforeLoadFn,\\n    TSSR,\\n    THandlers\\n  >,\\n): Route<\\n  TRegister,\\n  TParentRoute,\\n  TPath,\\n  TFullPath,\\n  TCustomId,\\n  TId,\\n  TSearchValidator,\\n  TParams,\\n  AnyContext,\\n  TRouteContextFn,\\n  TBeforeLoadFn,\\n  TLoaderDeps,\\n  TLoaderFn,\\n  TChildren,\\n  unknown,\\n  TSSR,\\n  THandlers\\n> {\\n  return new Route<\\n    TRegister,\\n    TParentRoute,\\n    TPath,\\n    TFullPath,\\n    TCustomId,\\n    TId,\\n    TSearchValidator,\\n    TParams,\\n    AnyContext,\\n    TRouteContextFn,\\n    TBeforeLoadFn,\\n    TLoaderDeps,\\n    TLoaderFn,\\n    TChildren,\\n    unknown,\\n    TSSR,\\n    THandlers\\n  >(options)\\n}\\n\\nexport type AnyRootRoute = RootRoute<\\n  any,\\n  any,\\n  any,\\n  any,\\n  any,\\n  any,\\n  any,\\n  any,\\n  any,\\n  any\\n>\\n\\nexport function createRootRouteWithContext<TRouterContext extends {}>() {\\n  return <\\n    TRegister = Register,\\n    TRouteContextFn = AnyContext,\\n    TBeforeLoadFn = AnyContext,\\n    TSearchValidator = undefined,\\n    TLoaderDeps extends Record<string, any> = {},\\n    TLoaderFn = undefined,\\n    TSSR = unknown,\\n    THandlers = undefined,\\n  >(\\n    options?: RootRouteOptions<\\n      TRegister,\\n      TSearchValidator,\\n      TRouterContext,\\n      TRouteContextFn,\\n      TBeforeLoadFn,\\n      TLoaderDeps,\\n      TLoaderFn,\\n      TSSR,\\n      THandlers\\n    >,\\n  ) => {\\n    return createRootRoute<\\n      TRegister,\\n      TSearchValidator,\\n      TRouterContext,\\n      TRouteContextFn,\\n      TBeforeLoadFn,\\n      TLoaderDeps,\\n      TLoaderFn,\\n      TSSR,\\n      THandlers\\n    >(options as any)\\n  }\\n}\\n\\n/**\\n * @deprecated Use the `createRootRouteWithContext` function instead.\\n */\\nexport const rootRouteWithContext = createRootRouteWithContext\\n\\nexport class RootRoute<\\n    in out TRegister = Register,\\n    in out TSearchValidator = undefined,\\n    in out TRouterContext = {},\\n    in out TRouteContextFn = AnyContext,\\n    in out TBeforeLoadFn = AnyContext,\\n    in out TLoaderDeps extends Record<string, any> = {},\\n    in out TLoaderFn = undefined,\\n    in out TChildren = unknown,\\n    in out TFileRouteTypes = unknown,\\n    in out TSSR = unknown,\\n    in out THandlers = undefined,\\n  >\\n  extends BaseRootRoute<\\n    TRegister,\\n    TSearchValidator,\\n    TRouterContext,\\n    TRouteContextFn,\\n    TBeforeLoadFn,\\n    TLoaderDeps,\\n    TLoaderFn,\\n    TChildren,\\n    TFileRouteTypes,\\n    TSSR,\\n    THandlers\\n  >\\n  implements\\n    RootRouteCore<\\n      TRegister,\\n      TSearchValidator,\\n      TRouterContext,\\n      TRouteContextFn,\\n      TBeforeLoadFn,\\n      TLoaderDeps,\\n      TLoaderFn,\\n      TChildren,\\n      TFileRouteTypes,\\n      TSSR,\\n      THandlers\\n    >\\n{\\n  /**\\n   * @deprecated `RootRoute` is now an internal implementation detail. Use `createRootRoute()` instead.\\n   */\\n  constructor(\\n    options?: RootRouteOptions<\\n      TRegister,\\n      TSearchValidator,\\n      TRouterContext,\\n      TRouteContextFn,\\n      TBeforeLoadFn,\\n      TLoaderDeps,\\n      TLoaderFn,\\n      TSSR,\\n      THandlers\\n    >,\\n  ) {\\n    super(options)\\n  }\\n\\n  injectMatch: InjectMatchRoute<RootRouteId> = (opts?: any) => {\\n    return injectMatch({\\n      select: opts?.select,\\n      from: this.id,\\n    } as any) as any\\n  }\\n\\n  injectRouteContext: InjectRouteContextRoute<RootRouteId> = (opts) => {\\n    return injectMatch({\\n      ...opts,\\n      from: this.id,\\n      select: (d) => (opts?.select ? opts.select(d.context) : d.context),\\n    }) as any\\n  }\\n\\n  injectSearch: InjectSearchRoute<RootRouteId> = (opts) => {\\n    return injectSearch({\\n      select: opts?.select,\\n      from: this.id,\\n    } as any) as any\\n  }\\n\\n  injectParams: InjectParamsRoute<RootRouteId> = (opts) => {\\n    return injectParams({\\n      select: opts?.select,\\n      from: this.id,\\n    } as any) as any\\n  }\\n\\n  injectLoaderDeps: InjectLoaderDepsRoute<RootRouteId> = (opts) => {\\n    return injectLoaderDeps({ ...opts, from: this.id } as any)\\n  }\\n\\n  injectLoaderData: InjectLoaderDataRoute<RootRouteId> = (opts) => {\\n    return injectLoaderData({ ...opts, from: this.id } as any)\\n  }\\n\\n  injectNavigate = (): UseNavigateResult<'/'> => {\\n    return injectNavigate({ from: this.fullPath })\\n  }\\n}\\n\\nexport function createRouteMask<\\n  TRouteTree extends AnyRoute,\\n  TFrom extends string,\\n  TTo extends string,\\n>(\\n  opts: {\\n    routeTree: TRouteTree\\n  } & ToMaskOptions<RouterCore<TRouteTree, 'never', false>, TFrom, TTo>,\\n): RouteMask<TRouteTree> {\\n  return opts as any\\n}\\n\\nexport type RouteComponent<TComponent = unknown> = Type<TComponent>\\n\\nexport type ErrorRouteComponent = Type<unknown>\\n\\nexport type NotFoundRouteComponent = Type<unknown>\\n\\nexport class NotFoundRoute<\\n  TRegister,\\n  TParentRoute extends AnyRootRoute,\\n  TRouterContext = AnyContext,\\n  TRouteContextFn = AnyContext,\\n  TBeforeLoadFn = AnyContext,\\n  TSearchValidator = undefined,\\n  TLoaderDeps extends Record<string, any> = {},\\n  TLoaderFn = undefined,\\n  TChildren = unknown,\\n  TSSR = unknown,\\n  THandlers = undefined,\\n> extends Route<\\n  TRegister,\\n  TParentRoute,\\n  '/404',\\n  '/404',\\n  '404',\\n  '404',\\n  TSearchValidator,\\n  {},\\n  TRouterContext,\\n  TRouteContextFn,\\n  TBeforeLoadFn,\\n  TLoaderDeps,\\n  TLoaderFn,\\n  TChildren,\\n  TSSR,\\n  THandlers\\n> {\\n  constructor(\\n    options: Omit<\\n      RouteOptions<\\n        TRegister,\\n        TParentRoute,\\n        string,\\n        string,\\n        string,\\n        string,\\n        TSearchValidator,\\n        {},\\n        TLoaderDeps,\\n        TLoaderFn,\\n        TRouterContext,\\n        TRouteContextFn,\\n        TBeforeLoadFn,\\n        TSSR,\\n        THandlers\\n      >,\\n      | 'caseSensitive'\\n      | 'parseParams'\\n      | 'stringifyParams'\\n      | 'path'\\n      | 'id'\\n      | 'params'\\n    >,\\n  ) {\\n    super({\\n      ...(options as any),\\n      id: '404',\\n    })\\n  }\\n}\\n\\nexport function createRootRoute<\\n  TRegister = Register,\\n  TSearchValidator = undefined,\\n  TRouterContext = {},\\n  TRouteContextFn = AnyContext,\\n  TBeforeLoadFn = AnyContext,\\n  TLoaderDeps extends Record<string, any> = {},\\n  TLoaderFn = undefined,\\n  TSSR = unknown,\\n  THandlers = undefined,\\n>(\\n  options?: RootRouteOptions<\\n    TRegister,\\n    TSearchValidator,\\n    TRouterContext,\\n    TRouteContextFn,\\n    TBeforeLoadFn,\\n    TLoaderDeps,\\n    TLoaderFn,\\n    TSSR,\\n    THandlers\\n  >,\\n): RootRoute<\\n  TRegister,\\n  TSearchValidator,\\n  TRouterContext,\\n  TRouteContextFn,\\n  TBeforeLoadFn,\\n  TLoaderDeps,\\n  TLoaderFn,\\n  unknown,\\n  unknown,\\n  TSSR,\\n  THandlers\\n> {\\n  return new RootRoute<\\n    TRegister,\\n    TSearchValidator,\\n    TRouterContext,\\n    TRouteContextFn,\\n    TBeforeLoadFn,\\n    TLoaderDeps,\\n    TLoaderFn,\\n    unknown,\\n    unknown,\\n    TSSR,\\n    THandlers\\n  >(options)\\n}\\n\",\"import {\\n  DestroyRef,\\n  inject,\\n  Injector,\\n  inputBinding,\\n  Provider,\\n  ViewContainerRef,\\n} from '@angular/core'\\nimport { RouteComponent } from './route'\\n\\n// Utility to dinamically render a component\\n// on the component that calls it\\n\\ntype RenderParams = {\\n  key?: string\\n  component: RouteComponent | null | undefined\\n  inputs?: Record<string, () => unknown>\\n  providers?: Provider[]\\n}\\n\\nexport function injectDynamicRenderer() {\\n  const vcr = inject(ViewContainerRef)\\n  const parent = inject(Injector)\\n\\n  inject(DestroyRef).onDestroy(() => {\\n    vcr.clear()\\n  })\\n\\n  let lastComponent: RouteComponent | null = null\\n  let lastKey: string | null = null\\n\\n  const clear = () => {\\n    if (lastComponent) vcr.clear()\\n    lastComponent = null\\n    lastKey = null\\n  }\\n\\n  return {\\n    clear,\\n    render: ({ component, providers = [], key, inputs }: RenderParams) => {\\n      if (lastComponent === component && lastKey === key) {\\n        return\\n      }\\n\\n      vcr.clear()\\n\\n      if (!component) return\\n\\n      const injector = Injector.create({ providers, parent })\\n      const bindings = Object.entries(inputs ?? {}).map(([name, value]) =>\\n        inputBinding(name, value),\\n      )\\n      const cmpRef = vcr.createComponent(component, { injector, bindings })\\n      cmpRef.changeDetectorRef.markForCheck()\\n\\n      lastComponent = component\\n      lastKey = key ?? null\\n    },\\n  }\\n}\\n\",\"import { ChangeDetectionStrategy, Component } from '@angular/core'\\n\\n@Component({\\n  template: `<p>Not found</p>`,\\n  changeDetection: ChangeDetectionStrategy.OnPush,\\n  host: { style: 'display: contents;' },\\n})\\nexport class DefaultNotFoundComponent {}\\n\",\"import {\\n  Component,\\n  computed,\\n  effect,\\n  inject,\\n  input,\\n  Provider,\\n  Signal,\\n} from '@angular/core'\\nimport { injectRouter } from './injectRouter'\\nimport { injectRouterState } from './injectRouterState'\\nimport {\\n  AnyRoute,\\n  AnyRouter,\\n  createControlledPromise,\\n  getLocationChangeInfo,\\n  rootRouteId,\\n} from '@tanstack/router-core'\\nimport warning from 'tiny-warning'\\nimport { DefaultNotFoundComponent } from './DefaultNotFound'\\nimport { MATCH_ID_INJECTOR_TOKEN } from './matchInjectorToken'\\nimport { RouteComponent } from './route'\\nimport { injectDynamicRenderer } from './dynamicRenderer'\\n\\n// In Angular, there is not concept of suspense or error boundaries,\\n// so we dont' need to wrap the inner content of the match.\\n// So in this adapter, we use derived state instead of state boundaries.\\n\\n// Equivalent to the OnRendered component.\\nfunction injectOnRendered({\\n  parentRouteId,\\n  rootRouteId,\\n}: {\\n  parentRouteId: Signal<string>\\n  rootRouteId: Signal<string>\\n}) {\\n  const router = injectRouter({ warn: false })\\n\\n  const location = injectRouterState({\\n    select: (s) => s.resolvedLocation?.state.key,\\n  })\\n\\n  const isRootRoute = computed(() => parentRouteId() === rootRouteId())\\n\\n  effect(() => {\\n    if (!isRootRoute()) return\\n    location() // Track location\\n\\n    router.emit({\\n      type: 'onRendered',\\n      ...getLocationChangeInfo(router.state),\\n    })\\n  })\\n}\\n\\n@Component({\\n  selector: 'router-match',\\n  template: '',\\n  standalone: true,\\n  host: {\\n    '[attr.data-matchId]': 'matchId()',\\n  },\\n})\\nexport class RouteMatch {\\n  matchId = input.required<string>()\\n\\n  router = injectRouter()\\n\\n  matchData = injectRouterState({\\n    select: (s) => {\\n      const matchIndex = s.matches.findIndex((d) => d.id === this.matchId())\\n      if (matchIndex === -1) return null\\n\\n      const match = s.matches[matchIndex]!\\n      const parentRouteId =\\n        matchIndex > 0 ? s.matches[matchIndex - 1]?.routeId : null\\n\\n      const routeId = match.routeId\\n      const route = this.router.routesById[routeId] as AnyRoute\\n      const remountFn =\\n        route.options.remountDeps ?? this.router.options.defaultRemountDeps\\n\\n      const remountDeps = remountFn?.({\\n        routeId,\\n        loaderDeps: match.loaderDeps,\\n        params: match._strictParams,\\n        search: match._strictSearch,\\n      })\\n      const key = remountDeps ? JSON.stringify(remountDeps) : undefined\\n\\n      return {\\n        key,\\n        route,\\n        match,\\n        parentRouteId,\\n      }\\n    },\\n  })\\n\\n  isFistRouteInRouteTree = computed(\\n    () => this.matchData()?.parentRouteId === rootRouteId,\\n  )\\n\\n  resolvedNoSsr = computed(() => {\\n    const match = this.matchData()?.match\\n    if (!match) return true\\n    return match.ssr === false || match.ssr === 'data-only'\\n  })\\n\\n  shouldClientOnly = computed(() => {\\n    const match = this.matchData()?.match\\n    if (!match) return true\\n    return this.resolvedNoSsr() || !!match._displayPending\\n  })\\n\\n  rendering = injectDynamicRenderer()\\n\\n  render = effect(() => {\\n    const matchData = this.matchData()\\n    if (!matchData) return\\n\\n    if (this.shouldClientOnly() && this.router.isServer) {\\n      this.rendering.clear()\\n      return\\n    }\\n\\n    const { match, route } = matchData\\n\\n    if (match.status === 'notFound') {\\n      const NotFoundComponent = getNotFoundComponent(this.router, route)\\n\\n      this.rendering.render({ component: NotFoundComponent })\\n    } else if (match.status === 'error') {\\n      const RouteErrorComponent =\\n        route.options.errorComponent ??\\n        this.router.options.defaultErrorComponent\\n\\n      this.rendering.render({\\n        component: RouteErrorComponent || null,\\n        inputs: {\\n          error: () => match.error,\\n          reset: () => {\\n            this.router.invalidate()\\n          },\\n          info: () => {\\n            return { componentStack: '' }\\n          },\\n        },\\n      })\\n    } else if (\\n      match._forcePending ||\\n      match._displayPending ||\\n      match.status === 'redirected' ||\\n      match.status === 'pending'\\n    ) {\\n      const pendingMinMs =\\n        route.options.pendingMinMs ?? this.router.options.defaultPendingMinMs\\n\\n      // If the compoennt is pending and has a minPendingMs,\\n      // we create a promise that will be awaited in the route core\\n      // to ensure that the pending state is displayed for that amount of time\\n      if (\\n        match.status === 'pending' &&\\n        pendingMinMs &&\\n        !match._nonReactive.minPendingPromise &&\\n        !this.router.isServer\\n      ) {\\n        const minPendingPromise = createControlledPromise<void>()\\n\\n        match._nonReactive.minPendingPromise = minPendingPromise\\n\\n        setTimeout(() => {\\n          minPendingPromise.resolve()\\n          match._nonReactive.minPendingPromise = undefined\\n        }, pendingMinMs)\\n      }\\n\\n      const PendingComponent =\\n        route.options.pendingComponent ??\\n        this.router.options.defaultPendingComponent\\n\\n      this.rendering.render({ component: PendingComponent })\\n    } else if (match.status === 'success') {\\n      const Component =\\n        route.options.component ??\\n        this.router.options.defaultComponent ??\\n        Outlet\\n\\n      const key = matchData.key\\n\\n      const matchIdSignal = computed(() => this.matchId())\\n      this.rendering.render({\\n        key,\\n        component: Component,\\n        providers: [\\n          {\\n            provide: MATCH_ID_INJECTOR_TOKEN,\\n            useValue: matchIdSignal,\\n          },\\n        ],\\n      })\\n    }\\n  })\\n}\\n\\n@Component({\\n  selector: 'outlet',\\n  template: '',\\n  standalone: true,\\n})\\nexport class Outlet {\\n  router = injectRouter()\\n  matchId = inject(MATCH_ID_INJECTOR_TOKEN)\\n\\n  routeId = injectRouterState({\\n    select: (s) =>\\n      s.matches.find((d) => d.id === this.matchId())?.routeId as string,\\n  })\\n\\n  route = computed(() => this.router.routesById[this.routeId()] as AnyRoute)\\n\\n  parentGlobalNotFound = injectRouterState({\\n    select: (s) => {\\n      const matches = s.matches\\n      const parentMatch = matches.find((d) => d.id === this.matchId())\\n      if (!parentMatch) return false\\n      return parentMatch.globalNotFound\\n    },\\n  })\\n\\n  childMatchId = injectRouterState({\\n    select: (s) => {\\n      const matches = s.matches\\n      const index = matches.findIndex((d) => d.id === this.matchId())\\n      const child = matches[index + 1]\\n      if (!child) return null\\n\\n      return child.id\\n    },\\n  })\\n\\n  rendering = injectDynamicRenderer()\\n\\n  render = effect(() => {\\n    if (this.parentGlobalNotFound()) {\\n      // Render not found with warning\\n      const NotFoundComponent = getNotFoundComponent(this.router, this.route())\\n      this.rendering.render({ component: NotFoundComponent })\\n      return\\n    }\\n    const childMatchId = this.childMatchId()\\n\\n    if (!childMatchId) {\\n      // Do not render anything\\n      this.rendering.clear()\\n      return\\n    }\\n\\n    this.rendering.render({\\n      component: RouteMatch,\\n      inputs: {\\n        matchId: () => this.childMatchId(),\\n      },\\n    })\\n  })\\n}\\n\\nfunction getNotFoundComponent(router: AnyRouter, route: AnyRoute) {\\n  let NotFoundComponent =\\n    route.options.notFoundComponent ?? router.options.defaultNotFoundComponent\\n\\n  if (NotFoundComponent) {\\n    return NotFoundComponent\\n  }\\n\\n  if (process.env.NODE_ENV === 'development') {\\n    warning(\\n      route.options.notFoundComponent,\\n      `A notFoundError was encountered on the route with ID \\\"${route.id}\\\", but a notFoundComponent option was not configured, nor was a router level defaultNotFoundComponent configured. Consider configuring at least one of these to avoid TanStack Router's overly generic defaultNotFoundComponent (<p>Page not found</p>)`,\\n    )\\n  }\\n\\n  return DefaultNotFoundComponent\\n}\\n\",\"import {\\n  computed,\\n  effect,\\n  signal,\\n  DestroyRef,\\n  inject,\\n  afterNextRender,\\n} from '@angular/core'\\nimport {\\n  getLocationChangeInfo,\\n  handleHashScroll,\\n  trimPathRight,\\n} from '@tanstack/router-core'\\nimport { injectRouter } from './injectRouter'\\nimport { injectRouterState } from './injectRouterState'\\nimport type { AnyRouter } from '@tanstack/router-core'\\n\\n// Track mount state per router to avoid double-loading\\nlet mountLoadForRouter: { router: AnyRouter | null; mounted: boolean } = {\\n  router: null,\\n  mounted: false,\\n}\\n\\n/**\\n * Helper function that sets up router transition logic.\\n * This should be called from Matches component to set up:\\n * - router.startTransition\\n * - router.startViewTransition\\n * - History subscription\\n * - Router event watchers\\n *\\n * Must be called during component initialization.\\n */\\nexport function injectTransitionerSetup() {\\n  const router = injectRouter()\\n\\n  // Skip on server - no transitions needed\\n  if (router.isServer) {\\n    return\\n  }\\n\\n  const destroyRef = inject(DestroyRef)\\n\\n  const isLoading = injectRouterState({\\n    select: (s) => s.isLoading,\\n  })\\n\\n  // Track if we're in a transition\\n  const isTransitioning = signal(false)\\n\\n  // Track pending state changes\\n  const hasPendingMatches = injectRouterState({\\n    select: (s) => s.matches.some((d) => d.status === 'pending'),\\n  })\\n\\n  // Track previous values for comparison\\n  let previousIsLoading: boolean | undefined\\n  let previousIsAnyPending: boolean | undefined\\n  let previousIsPagePending: boolean | undefined\\n\\n  const isAnyPending = computed(\\n    () => isLoading() || isTransitioning() || hasPendingMatches(),\\n  )\\n\\n  const isPagePending = computed(() => isLoading() || hasPendingMatches())\\n\\n  // Implement startTransition similar to React/Solid\\n  // Angular doesn't have a native startTransition like React 18, so we simulate it\\n  router.startTransition = (fn: () => void | Promise<void>) => {\\n    isTransitioning.set(true)\\n    // Also update the router state so useMatch can check it\\n    try {\\n      router.__store.setState((s) => ({ ...s, isTransitioning: true }))\\n    } catch {\\n      // Ignore errors if component is unmounted\\n    }\\n\\n    // Execute the function\\n    const result = fn()\\n\\n    // Handle async functions\\n    if (result instanceof Promise) {\\n      result\\n        .then(() => {\\n          isTransitioning.set(false)\\n          try {\\n            router.__store.setState((s) => ({ ...s, isTransitioning: false }))\\n          } catch {\\n            // Ignore errors if component is unmounted\\n          }\\n        })\\n        .catch(() => {\\n          isTransitioning.set(false)\\n          try {\\n            router.__store.setState((s) => ({ ...s, isTransitioning: false }))\\n          } catch {\\n            // Ignore errors if component is unmounted\\n          }\\n        })\\n    } else {\\n      // For sync functions, use setTimeout to allow Angular to process updates\\n      setTimeout(() => {\\n        isTransitioning.set(false)\\n        try {\\n          router.__store.setState((s) => ({ ...s, isTransitioning: false }))\\n        } catch {\\n          // Ignore errors if component is unmounted\\n        }\\n      }, 0)\\n    }\\n  }\\n\\n  // Angular doesn't have View Transitions API support like Vue, but we can still\\n  // set up the function for compatibility\\n  const originalStartViewTransition:\\n    | undefined\\n    | ((fn: () => Promise<void>) => void) =\\n    (router as any).__tsrOriginalStartViewTransition ??\\n    router.startViewTransition\\n\\n  ;(router as any).__tsrOriginalStartViewTransition =\\n    originalStartViewTransition\\n\\n  router.startViewTransition = (fn: () => Promise<void>) => {\\n    return originalStartViewTransition?.(fn)\\n  }\\n\\n  // Subscribe to location changes and try to load the new location\\n  let unsubscribe: (() => void) | undefined\\n\\n  afterNextRender(() => {\\n    unsubscribe = router.history.subscribe(router.load)\\n\\n    const nextLocation = router.buildLocation({\\n      to: router.latestLocation.pathname,\\n      search: true,\\n      params: true,\\n      hash: true,\\n      state: true,\\n      _includeValidateSearch: true,\\n    })\\n\\n    if (\\n      trimPathRight(router.latestLocation.href) !==\\n      trimPathRight(nextLocation.href)\\n    ) {\\n      router.commitLocation({ ...nextLocation, replace: true })\\n    }\\n  })\\n\\n  // Track if component is mounted to prevent updates after unmount\\n  const isMounted = signal(false)\\n\\n  afterNextRender(() => {\\n    isMounted.set(true)\\n    if (!isAnyPending()) {\\n      router.__store.setState((s) =>\\n        s.status === 'pending'\\n          ? { ...s, status: 'idle', resolvedLocation: s.location }\\n          : s,\\n      )\\n    }\\n  })\\n\\n  destroyRef.onDestroy(() => {\\n    isMounted.set(false)\\n    if (unsubscribe) {\\n      unsubscribe()\\n    }\\n  })\\n\\n  // Try to load the initial location\\n  afterNextRender(() => {\\n    if (\\n      (typeof window !== 'undefined' && router.ssr) ||\\n      (mountLoadForRouter.router === router && mountLoadForRouter.mounted)\\n    ) {\\n      return\\n    }\\n    mountLoadForRouter = { router, mounted: true }\\n    const tryLoad = async () => {\\n      try {\\n        await router.load()\\n      } catch (err) {\\n        console.error(err)\\n      }\\n    }\\n    tryLoad()\\n  })\\n\\n  // Setup effects for emitting events\\n  // All effects check isMounted to prevent updates after unmount\\n\\n  // Watch for onLoad event\\n  effect(() => {\\n    if (!isMounted()) return\\n    const currentIsLoading = isLoading()\\n    try {\\n      if (previousIsLoading && !currentIsLoading) {\\n        router.emit({\\n          type: 'onLoad',\\n          ...getLocationChangeInfo(router.state),\\n        })\\n      }\\n      previousIsLoading = currentIsLoading\\n    } catch {\\n      // Ignore errors if component is unmounted\\n    }\\n  })\\n\\n  // Watch for onBeforeRouteMount event\\n  effect(() => {\\n    if (!isMounted()) return\\n    const currentIsPagePending = isPagePending()\\n    try {\\n      if (previousIsPagePending && !currentIsPagePending) {\\n        router.emit({\\n          type: 'onBeforeRouteMount',\\n          ...getLocationChangeInfo(router.state),\\n        })\\n      }\\n      previousIsPagePending = currentIsPagePending\\n    } catch {\\n      // Ignore errors if component is unmounted\\n    }\\n  })\\n\\n  // Watch for onResolved event\\n  effect(() => {\\n    if (!isMounted()) return\\n    const currentIsAnyPending = isAnyPending()\\n    try {\\n      if (!currentIsAnyPending && router.__store.state.status === 'pending') {\\n        router.__store.setState((s) => ({\\n          ...s,\\n          status: 'idle',\\n          resolvedLocation: s.location,\\n        }))\\n      }\\n\\n      // The router was pending and now it's not\\n      if (previousIsAnyPending && !currentIsAnyPending) {\\n        const changeInfo = getLocationChangeInfo(router.state)\\n        router.emit({\\n          type: 'onResolved',\\n          ...changeInfo,\\n        })\\n\\n        if (changeInfo.hrefChanged) {\\n          handleHashScroll(router)\\n        }\\n      }\\n      previousIsAnyPending = currentIsAnyPending\\n    } catch {\\n      // Ignore errors if component is unmounted\\n    }\\n  })\\n}\\n\",\"import { Component, effect } from '@angular/core'\\nimport { injectRouterState } from './injectRouterState'\\nimport { injectDynamicRenderer } from './dynamicRenderer'\\nimport { RouteMatch } from './Match'\\nimport { injectTransitionerSetup } from './transitioner'\\n\\n@Component({ selector: 'router-matches', template: '', standalone: true })\\nexport class Matches {\\n  private matchId = injectRouterState({\\n    select: (s) => s.matches[0]?.id,\\n  })\\n\\n  renderer = injectDynamicRenderer()\\n  transitioner = injectTransitionerSetup()\\n\\n  render = effect(() => {\\n    const matchId = this.matchId()\\n\\n    if (!matchId) {\\n      this.renderer.clear()\\n      return\\n    }\\n\\n    this.renderer.render({\\n      component: RouteMatch,\\n      inputs: {\\n        matchId: () => matchId,\\n      },\\n    })\\n  })\\n}\\n\",\"import { Component, effect, input, untracked } from '@angular/core'\\nimport { AnyRouter } from '@tanstack/router-core'\\nimport { injectDynamicRenderer } from './dynamicRenderer'\\nimport { Matches } from './Macthes'\\nimport { getRouterInjectionKey } from './routerInjectionToken'\\n\\n@Component({ selector: 'router-provider', template: '', standalone: true })\\nexport class RouterProvider {\\n  router = input.required<AnyRouter>()\\n  renderer = injectDynamicRenderer()\\n\\n  render = effect(() => {\\n    const router = untracked(this.router)\\n    this.renderer.render({\\n      component: Matches,\\n      providers: [\\n        {\\n          provide: getRouterInjectionKey(),\\n          useValue: router,\\n        },\\n      ],\\n    })\\n  })\\n}\\n\",\"import { injectMatch } from './injectMatch'\\nimport type { Signal } from '@angular/core'\\nimport type {\\n  AnyRouter,\\n  RegisteredRouter,\\n  UseRouteContextBaseOptions,\\n  UseRouteContextOptions,\\n  UseRouteContextResult,\\n} from '@tanstack/router-core'\\n\\nexport type InjectRouteContextRoute<out TFrom> = <\\n  TRouter extends AnyRouter = RegisteredRouter,\\n  TSelected = unknown,\\n>(\\n  opts?: UseRouteContextBaseOptions<TRouter, TFrom, true, TSelected>,\\n) => Signal<UseRouteContextResult<TRouter, TFrom, true, TSelected>>\\n\\nexport function injectRouterContext<\\n  TRouter extends AnyRouter = RegisteredRouter,\\n  const TFrom extends string | undefined = undefined,\\n  TStrict extends boolean = true,\\n  TSelected = unknown,\\n>(\\n  opts: UseRouteContextOptions<TRouter, TFrom, TStrict, TSelected>,\\n): Signal<UseRouteContextResult<TRouter, TFrom, TStrict, TSelected>> {\\n  return injectMatch({\\n    ...opts,\\n    select: (match) =>\\n      opts.select ? opts.select(match.context) : match.context,\\n  }) as any\\n}\\n\",\"import { Signal } from '@angular/core'\\nimport { AnyRouter, RegisteredRouter, RouterState } from '@tanstack/router-core'\\nimport { injectRouterState } from './injectRouterState'\\n\\nexport interface InjectLocationOptions<TRouter extends AnyRouter, TSelected> {\\n  select?: (\\n    location: RouterState<TRouter['routeTree']>['location'],\\n  ) => TSelected\\n}\\n\\nexport type InjectLocationResult<\\n  TRouter extends AnyRouter,\\n  TSelected,\\n> = unknown extends TSelected\\n  ? RouterState<TRouter['routeTree']>['location']\\n  : TSelected\\n\\nexport function injectLocation<\\n  TRouter extends AnyRouter = RegisteredRouter,\\n  TSelected = unknown,\\n>(\\n  opts: InjectLocationOptions<TRouter, TSelected>,\\n): Signal<InjectLocationResult<TRouter, TSelected>> {\\n  return injectRouterState({\\n    select: (s) => (opts.select ? opts.select(s.location) : s.location),\\n  }) as any\\n}\\n\",\"import { effect, signal, Signal } from '@angular/core'\\nimport {\\n  BlockerFnArgs,\\n  HistoryLocation,\\n  HistoryAction,\\n} from '@tanstack/history'\\nimport type {\\n  AnyRoute,\\n  AnyRouter,\\n  ParseRoute,\\n  RegisteredRouter,\\n} from '@tanstack/router-core'\\nimport { injectRouter } from './injectRouter'\\n\\ninterface ShouldBlockFnLocation<\\n  out TRouteId,\\n  out TFullPath,\\n  out TAllParams,\\n  out TFullSearchSchema,\\n> {\\n  routeId: TRouteId\\n  fullPath: TFullPath\\n  pathname: string\\n  params: TAllParams\\n  search: TFullSearchSchema\\n}\\n\\ntype AnyShouldBlockFnLocation = ShouldBlockFnLocation<any, any, any, any>\\n\\ntype MakeShouldBlockFnLocationUnion<\\n  TRouter extends AnyRouter = RegisteredRouter,\\n  TRoute extends AnyRoute = ParseRoute<TRouter['routeTree']>,\\n> = TRoute extends any\\n  ? ShouldBlockFnLocation<\\n      TRoute['id'],\\n      TRoute['fullPath'],\\n      TRoute['types']['allParams'],\\n      TRoute['types']['fullSearchSchema']\\n    >\\n  : never\\n\\ntype BlockerResolver<TRouter extends AnyRouter = RegisteredRouter> =\\n  | {\\n      status: 'blocked'\\n      current: MakeShouldBlockFnLocationUnion<TRouter>\\n      next: MakeShouldBlockFnLocationUnion<TRouter>\\n      action: HistoryAction\\n      proceed: () => void\\n      reset: () => void\\n    }\\n  | {\\n      status: 'idle'\\n      current: undefined\\n      next: undefined\\n      action: undefined\\n      proceed: undefined\\n      reset: undefined\\n    }\\n\\ntype ShouldBlockFnArgs<TRouter extends AnyRouter = RegisteredRouter> = {\\n  current: MakeShouldBlockFnLocationUnion<TRouter>\\n  next: MakeShouldBlockFnLocationUnion<TRouter>\\n  action: HistoryAction\\n}\\n\\nexport type ShouldBlockFn<TRouter extends AnyRouter = RegisteredRouter> = (\\n  args: ShouldBlockFnArgs<TRouter>,\\n) => boolean | Promise<boolean>\\n\\nexport type UseBlockerOpts<\\n  TRouter extends AnyRouter = RegisteredRouter,\\n  TWithResolver extends boolean = boolean,\\n> = {\\n  shouldBlockFn: ShouldBlockFn<TRouter>\\n  enableBeforeUnload?: boolean | (() => boolean)\\n  // TODO: why is disabled needed? It isn't reactive\\n  disabled?: boolean\\n  withResolver?: TWithResolver\\n}\\n\\nexport type InjectBlockerOpts<\\n  TRouter extends AnyRouter = RegisteredRouter,\\n  TWithResolver extends boolean = boolean,\\n> = {\\n  shouldBlockFn: ShouldBlockFn<TRouter>\\n  enableBeforeUnload?: boolean | (() => boolean)\\n  disabled?: boolean\\n  withResolver?: TWithResolver\\n}\\n\\nexport function injectBlocker<\\n  TRouter extends AnyRouter = RegisteredRouter,\\n  TWithResolver extends boolean = boolean,\\n>(\\n  opts: InjectBlockerOpts<TRouter, TWithResolver>,\\n): TWithResolver extends true ? Signal<BlockerResolver<TRouter>> : void {\\n  const shouldBlockFn = opts.shouldBlockFn as ShouldBlockFn<AnyRouter>\\n  const router = injectRouter()\\n\\n  const resolver = signal<BlockerResolver>({\\n    status: 'idle',\\n    current: undefined,\\n    next: undefined,\\n    action: undefined,\\n    proceed: undefined,\\n    reset: undefined,\\n  })\\n\\n  effect((onCleanup) => {\\n    const blockerFnComposed = async (blockerFnArgs: BlockerFnArgs) => {\\n      function getLocation(\\n        location: HistoryLocation,\\n      ): AnyShouldBlockFnLocation {\\n        const parsedLocation = router.parseLocation(location)\\n        const matchedRoutes = router.getMatchedRoutes(parsedLocation.pathname)\\n        if (matchedRoutes.foundRoute === undefined) {\\n          return {\\n            routeId: '__notFound__',\\n            fullPath: parsedLocation.pathname,\\n            pathname: parsedLocation.pathname,\\n            params: matchedRoutes.routeParams,\\n            search: parsedLocation.search,\\n          }\\n        }\\n        return {\\n          routeId: matchedRoutes.foundRoute.id,\\n          fullPath: matchedRoutes.foundRoute.fullPath,\\n          pathname: parsedLocation.pathname,\\n          params: matchedRoutes.routeParams,\\n          search: parsedLocation.search,\\n        }\\n      }\\n\\n      const current = getLocation(blockerFnArgs.currentLocation)\\n      const next = getLocation(blockerFnArgs.nextLocation)\\n\\n      if (\\n        current.routeId === '__notFound__' &&\\n        next.routeId !== '__notFound__'\\n      ) {\\n        return false\\n      }\\n\\n      const shouldBlock = await shouldBlockFn({\\n        action: blockerFnArgs.action,\\n        current,\\n        next,\\n      })\\n      if (!opts.withResolver) {\\n        return shouldBlock\\n      }\\n\\n      if (!shouldBlock) {\\n        return false\\n      }\\n\\n      const promise = new Promise<boolean>((resolve) => {\\n        resolver.set({\\n          status: 'blocked',\\n          current,\\n          next,\\n          action: blockerFnArgs.action,\\n          proceed: () => resolve(false),\\n          reset: () => resolve(true),\\n        })\\n      })\\n\\n      const canNavigateAsync = await promise\\n      resolver.set({\\n        status: 'idle',\\n        current: undefined,\\n        next: undefined,\\n        action: undefined,\\n        proceed: undefined,\\n        reset: undefined,\\n      })\\n\\n      return canNavigateAsync\\n    }\\n\\n    const disposeBlock = opts.disabled\\n      ? undefined\\n      : router.history.block({\\n          blockerFn: blockerFnComposed,\\n          enableBeforeUnload: opts.enableBeforeUnload,\\n        })\\n\\n    onCleanup(() => disposeBlock?.())\\n  })\\n\\n  return resolver.asReadonly() as any\\n}\\n\",\"import { injectRouterState } from './injectRouterState'\\n\\nexport function injectCanGoBack() {\\n  return injectRouterState({\\n    select: (s) => s.location.state.__TSR_index !== 0,\\n  })\\n}\\n\",\"import {\\n  ElementRef,\\n  inject,\\n  afterNextRender,\\n  afterRenderEffect,\\n} from '@angular/core'\\n\\nexport function injectIntersectionObserver(\\n  callback: (entry: IntersectionObserverEntry | undefined) => void,\\n  intersectionObserverOptions: IntersectionObserverInit,\\n  disabled: () => boolean,\\n) {\\n  const elementRef = inject(ElementRef)\\n\\n  afterRenderEffect((onCleanup) => {\\n    const isDisabled = disabled()\\n    const element = elementRef.nativeElement as HTMLElement | null\\n    if (isDisabled || !element) return\\n\\n    const observer = new IntersectionObserver(\\n      ([entry]) => callback(entry),\\n      intersectionObserverOptions,\\n    )\\n\\n    observer.observe(element)\\n\\n    onCleanup(() => {\\n      observer.disconnect()\\n    })\\n  })\\n}\\n\",\"// Router\\nexport { createRouter } from './router'\\n\\n// Route creation\\nexport {\\n  createRoute,\\n  createRootRoute,\\n  createRootRouteWithContext,\\n  rootRouteWithContext,\\n  createRouteMask,\\n  getRouteApi,\\n  Route,\\n  RootRoute,\\n  NotFoundRoute,\\n  RouteApi,\\n  type AnyRootRoute,\\n  type RouteComponent,\\n  type ErrorRouteComponent,\\n  type NotFoundRouteComponent,\\n} from './route'\\n\\n// Router Provider\\nexport { RouterProvider } from './RouterProvider'\\n\\n// Components\\nexport { Outlet, RouteMatch } from './Match'\\nexport { Matches } from './Macthes'\\n\\n// Injection functions\\nexport { injectRouter, type InjectRouterResult } from './injectRouter'\\n\\nexport {\\n  injectRouterState,\\n  type InjectRouterStateOptions,\\n  type InjectRouterStateResult,\\n} from './injectRouterState'\\n\\nexport { injectNavigate, type InjectNavigateResult } from './injectNavigate'\\n\\nexport {\\n  injectMatch,\\n  type InjectMatchOptions,\\n  type InjectMatchResult,\\n  type InjectMatchRoute,\\n  type InjectMatchBaseOptions,\\n} from './injectMatch'\\n\\nexport {\\n  injectParams,\\n  type InjectParamsOptions,\\n  type InjectParamsRoute,\\n  type InjectParamsBaseOptions,\\n} from './injectParams'\\n\\nexport {\\n  injectSearch,\\n  type InjectSearchOptions,\\n  type InjectSearchRoute,\\n  type InjectSearchBaseOptions,\\n} from './injectSearch'\\n\\nexport {\\n  injectLoaderData,\\n  type InjectLoaderDataOptions,\\n  type InjectLoaderDataRoute,\\n  type InjectLoaderDataBaseOptions,\\n} from './injectLoaderData'\\n\\nexport {\\n  injectLoaderDeps,\\n  type InjectLoaderDepsOptions,\\n  type InjectLoaderDepsRoute,\\n  type InjectLoaderDepsBaseOptions,\\n} from './injectLoaderDeps'\\n\\nexport {\\n  injectRouterContext,\\n  type InjectRouteContextRoute,\\n} from './injectRouteContext'\\n\\nexport {\\n  injectLocation,\\n  type InjectLocationOptions,\\n  type InjectLocationResult,\\n} from './injectLocationResult'\\n\\nexport {\\n  injectBlocker,\\n  type InjectBlockerOpts,\\n  type UseBlockerOpts,\\n  type ShouldBlockFn,\\n} from './injectBlocker'\\n\\nexport { injectCanGoBack } from './injectCanGoBack'\\n\\n// Link\\nexport { type LinkInputOptions } from './Link'\\n\\n// Utilities\\nexport { injectIntersectionObserver } from './injectIntersectionObserver'\\nexport { injectDynamicRenderer } from './dynamicRenderer'\\nexport { getRouterInjectionKey } from './routerInjectionToken'\\nexport { MATCH_ID_INJECTOR_TOKEN } from './matchInjectorToken'\\n\\n// Re-export types from router-core that are commonly used\\nexport type {\\n  AnyRouter,\\n  RegisteredRouter,\\n  RouterState,\\n  LinkOptions,\\n  NavigateOptions,\\n  RouteOptions,\\n  RootRouteOptions,\\n} from '@tanstack/router-core'\\n\",\"/**\\n * Generated bundle index. Do not edit.\\n */\\n\\nexport * from './index';\\n\"],\"names\":[],\"mappings\":\";;;;;;AA6CO,MAAM,YAAY,GAAmB,CAAC,OAAY,KAAI;AAC3D,IAAA,OAAO,IAAI,MAAM,CAAC,OAAO,CAAC;AAC5B;AAEM,MAAO,MAMX,SAAQ,UAMT,CAAA;AACC,IAAA,WAAA,CACE,OAMC,EAAA;QAED,KAAK,CAAC,OAAO,CAAC;IAChB;AACD;;MCvEY,uBAAuB,GAAG,IAAI,cAAc,CAEvD,mBAAmB,EAAE;AACrB,IAAA,OAAO,EAAE,MAAM,MAAM,CAAC,SAAS,CAAC;AACjC,CAAA;;ACGD,MAAM,kBAAkB,GAAG,IAAI,cAAc,CAAY,QAAQ,CAAC;SAElD,qBAAqB,GAAA;AACnC,IAAA,IAAI,OAAO,QAAQ,KAAK,WAAW,EAAE;AACnC,QAAA,OAAO,kBAAkB;IAC3B;AAEA,IAAA,IAAI,MAAM,CAAC,4BAA4B,EAAE;QACvC,OAAO,MAAM,CAAC,4BAA4B;IAC5C;AAEA,IAAA,MAAM,CAAC,4BAA4B,GAAG,kBAAyB;AAE/D,IAAA,OAAO,kBAAkB;AAC3B;;AClBM,SAAU,YAAY,CAE1B,IAAyB,EAAA;AACzB,IAAA,MAAM,MAAM,GAAG,MAAM,CAAC,qBAAqB,EAAE,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,CAAC;AAClE,IAAA,OAAO,CACL,EAAE,CAAC,IAAI,EAAE,IAAI,IAAI,IAAI,KAAK,CAAC,MAAM,CAAC,EAClC,6DAA6D,CAC9D;AACD,IAAA,OAAO,MAAa;AACtB;;ACKM,SAAU,iBAAiB,CAI/B,IAAmD,EAAA;IAEnD,MAAM,aAAa,GAAG,YAAY,CAAC;AACjC,QAAA,IAAI,EAAE,IAAI,EAAE,MAAM,KAAK,SAAS;AACjC,KAAA,CAAC;AAEF,IAAA,MAAM,MAAM,GAAG,IAAI,EAAE,MAAM,IAAI,aAAa;IAE5C,OAAO,WAAW,CAAC,MAAM,CAAC,OAAO,EAAE,CAAC,KAAK,KAAI;QAC3C,IAAI,IAAI,EAAE,MAAM;AAAE,YAAA,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC;AAE3C,QAAA,OAAO,KAAK;AACd,IAAA,CAAC,CAAwD;AAC3D;;ACiBM,SAAU,WAAW,CAOzB,IAMC,EAAA;AAID,IAAA,MAAM,cAAc,GAAG,MAAM,CAAC,uBAAuB,CAAC;IAEtD,MAAM,UAAU,GAAG,iBAAiB,CAAC;AACnC,QAAA,MAAM,EAAE,CAAC,KAAK,KAAI;AAChB,YAAA,MAAM,KAAK,GAAG,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,KACjC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,KAAK,CAAC,CAAC,OAAO,GAAG,CAAC,CAAC,EAAE,KAAK,cAAc,EAAE,CAChE;AAED,YAAA,IAAI,KAAK,KAAK,SAAS,EAAE;;AAEvB,gBAAA,MAAM,YAAY,GAAG,KAAK,CAAC,cAAc,EAAE,IAAI,CAAC,CAAC,CAAC,KAChD,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,KAAK,CAAC,CAAC,OAAO,GAAG,CAAC,CAAC,EAAE,KAAK,cAAc,EAAE,CAChE;;AAGD,gBAAA,MAAM,gBAAgB,GACpB,CAAC,YAAY,IAAI,CAAC,KAAK,CAAC,eAAe,KAAK,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC;gBAEvE,OAAO;AACL,oBAAA,KAAK,EAAE,SAAS;oBAChB,gBAAgB;iBACR;YACZ;YAEA,OAAO;AACL,gBAAA,KAAK,EAAE,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,KAAK;AAC/C,gBAAA,gBAAgB,EAAE,KAAK;aACf;QACZ,CAAC;AACF,KAAA,CAAC;;;IAIF,OAAO,QAAQ,CAAC,MAAK;AACnB,QAAA,MAAM,KAAK,GAAG,UAAU,EAAE;AAC1B,QAAA,IAAI,KAAK,CAAC,gBAAgB,EAAE;YAC1B,MAAM,IAAI,KAAK,CACb,CAAA,eAAA,EAAkB,IAAI,CAAC,IAAI,GAAG,yBAAyB,IAAI,CAAC,IAAI,CAAA,CAAA,CAAG,GAAG,kBAAkB,CAAA,CAAE,CAC3F;QACH;QACA,OAAO,KAAK,CAAC,KAAY;AAC3B,IAAA,CAAC,CAAC;AACJ;;AC9EM,SAAU,gBAAgB,CAM9B,IAAiE,EAAA;AAEjE,IAAA,OAAO,WAAW,CAAC;QACjB,IAAI,EAAE,IAAI,CAAC,IAAK;QAChB,MAAM,EAAE,IAAI,CAAC,MAA0B;QACvC,MAAM,EAAE,CAAC,CAAM,KACb,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,UAAU;AAClD,KAAA,CAAQ;AAClB;;AChBM,SAAU,gBAAgB,CAK9B,IAAwD,EAAA;IAExD,MAAM,EAAE,MAAM,EAAE,GAAG,IAAI,EAAE,GAAG,IAAI;AAChC,IAAA,OAAO,WAAW,CAAC;AACjB,QAAA,GAAG,IAAI;QACP,MAAM,EAAE,CAAC,CAAC,MAAM,MAAM,GAAG,MAAM,CAAC,CAAC,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,UAAU,CAAC;AAC9D,KAAA,CAAQ;AACX;;ACCM,SAAU,YAAY,CAO1B,IAMC,EAAA;AAID,IAAA,OAAO,WAAW,CAAC;QACjB,IAAI,EAAE,IAAI,CAAC,IAAK;QAChB,MAAM,EAAE,IAAI,CAAC,MAA0B;QACvC,WAAW,EAAE,IAAI,CAAC,WAAW;AAC7B,QAAA,MAAM,EAAE,CAAC,KAAU,KAAI;AACrB,YAAA,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,KAAK,KAAK,GAAG,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC,aAAa;AAEzE,YAAA,OAAO,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,GAAG,MAAM;QACnD,CAAC;AACK,KAAA,CAAgB;AAC1B;;AC3BM,SAAU,YAAY,CAO1B,IAMC,EAAA;AAID,IAAA,OAAO,WAAW,CAAC;QACjB,IAAI,EAAE,IAAI,CAAC,IAAK;QAChB,MAAM,EAAE,IAAI,CAAC,MAAM;QACnB,WAAW,EAAE,IAAI,CAAC,WAAW;AAC7B,QAAA,MAAM,EAAE,CAAC,KAAU,KAAI;YACrB,OAAO,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,KAAK,CAAC,MAAM;QAC/D,CAAC;AACK,KAAA,CAAQ;AAClB;;AC7DM,SAAU,cAAc,CAG5B,YAED,EAAA;AACC,IAAA,MAAM,MAAM,GAAG,YAAY,EAAE;AAE7B,IAAA,QAAQ,CAAC,OAAwB,KAAI;QACnC,OAAO,MAAM,CAAC,QAAQ,CAAC;AACrB,YAAA,GAAG,OAAO;AACV,YAAA,IAAI,EAAE,OAAO,CAAC,IAAI,IAAI,YAAY,EAAE,IAAI;AACzC,SAAA,CAAC;AACJ,IAAA,CAAC;AACH;;ACkDM,SAAU,WAAW,CAGzB,EAAyD,EAAA;AACzD,IAAA,OAAO,IAAI,QAAQ,CAAe,EAAE,EAAE,EAAE,CAAC;AAC3C;AAEM,MAAO,QAGX,SAAQ,YAA0B,CAAA;AAClC;;AAEG;IACH,WAAA,CAAY,EAAE,EAAE,EAAe,EAAA;AAC7B,QAAA,KAAK,CAAC,EAAE,EAAE,EAAE,CAAC;AAGf,QAAA,IAAA,CAAA,WAAW,GAA0B,CAAC,IAAI,KAAI;AAC5C,YAAA,OAAO,WAAW,CAAC;gBACjB,MAAM,EAAE,IAAI,EAAE,MAAM;gBACpB,IAAI,EAAE,IAAI,CAAC,EAAE;AACP,aAAA,CAAQ;AAClB,QAAA,CAAC;AAED,QAAA,IAAA,CAAA,kBAAkB,GAAiC,CAAC,IAAI,KAAI;AAC1D,YAAA,OAAO,WAAW,CAAC;gBACjB,IAAI,EAAE,IAAI,CAAC,EAAS;gBACpB,MAAM,EAAE,CAAC,CAAC,MAAM,IAAI,EAAE,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC;AACnE,aAAA,CAAQ;AACX,QAAA,CAAC;AAED,QAAA,IAAA,CAAA,YAAY,GAA2B,CAAC,IAAI,KAAI;AAC9C,YAAA,OAAO,YAAY,CAAC;gBAClB,MAAM,EAAE,IAAI,EAAE,MAAM;gBACpB,IAAI,EAAE,IAAI,CAAC,EAAE;AACP,aAAA,CAAQ;AAClB,QAAA,CAAC;AAED,QAAA,IAAA,CAAA,YAAY,GAA2B,CAAC,IAAI,KAAI;AAC9C,YAAA,OAAO,YAAY,CAAC;gBAClB,MAAM,EAAE,IAAI,EAAE,MAAM;gBACpB,IAAI,EAAE,IAAI,CAAC,EAAE;AACP,aAAA,CAAQ;AAClB,QAAA,CAAC;AAED,QAAA,IAAA,CAAA,gBAAgB,GAA+B,CAAC,IAAI,KAAI;AACtD,YAAA,OAAO,gBAAgB,CAAC,EAAE,GAAG,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,EAAE,EAAE,MAAM,EAAE,KAAK,EAAS,CAAC;AAC3E,QAAA,CAAC;AAED,QAAA,IAAA,CAAA,gBAAgB,GAA+B,CAAC,IAAI,KAAI;AACtD,YAAA,OAAO,gBAAgB,CAAC,EAAE,GAAG,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,EAAE,EAAE,MAAM,EAAE,KAAK,EAAS,CAAC;AAC3E,QAAA,CAAC;QAED,IAAA,CAAA,cAAc,GAAG,MAEb;AACF,YAAA,MAAM,MAAM,GAAG,YAAY,EAAE;AAC7B,YAAA,OAAO,cAAc,CAAC;gBACpB,IAAI,EAAE,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,EAAY,CAAC,CAAC,QAAQ;AACpD,aAAA,CAAC;AACJ,QAAA,CAAC;AAED,QAAA,IAAA,CAAA,QAAQ,GAAG,CAAC,IAAoB,KAAI;AAClC,YAAA,OAAO,QAAQ,CAAC,EAAE,OAAO,EAAE,IAAI,CAAC,EAAY,EAAE,GAAG,IAAI,EAAE,CAAC;AAC1D,QAAA,CAAC;IAjDD;AAkDD;AAEK,MAAO,KA2BX,SAAQ,SAmBP,CAAA;AAuBD;;AAEG;AACH,IAAA,WAAA,CACE,OAiBC,EAAA;QAED,KAAK,CAAC,OAAO,CAAC;AAGhB,QAAA,IAAA,CAAA,WAAW,GAA0B,CAAC,IAAU,KAAI;AAClD,YAAA,OAAO,WAAW,CAAC;gBACjB,MAAM,EAAE,IAAI,EAAE,MAAM;gBACpB,IAAI,EAAE,IAAI,CAAC,EAAE;AACP,aAAA,CAAQ;AAClB,QAAA,CAAC;AAED,QAAA,IAAA,CAAA,kBAAkB,GAAiC,CAAC,IAAU,KAAI;AAChE,YAAA,OAAO,WAAW,CAAC;AACjB,gBAAA,GAAG,IAAI;gBACP,IAAI,EAAE,IAAI,CAAC,EAAE;gBACb,MAAM,EAAE,CAAC,CAAC,MAAM,IAAI,EAAE,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC;AACnE,aAAA,CAAQ;AACX,QAAA,CAAC;AAED,QAAA,IAAA,CAAA,YAAY,GAA2B,CAAC,IAAI,KAAI;AAC9C,YAAA,OAAO,YAAY,CAAC;gBAClB,MAAM,EAAE,IAAI,EAAE,MAAM;gBACpB,IAAI,EAAE,IAAI,CAAC,EAAE;AACP,aAAA,CAAQ;AAClB,QAAA,CAAC;AAED,QAAA,IAAA,CAAA,YAAY,GAA2B,CAAC,IAAI,KAAI;AAC9C,YAAA,OAAO,YAAY,CAAC;gBAClB,MAAM,EAAE,IAAI,EAAE,MAAM;gBACpB,IAAI,EAAE,IAAI,CAAC,EAAE;AACP,aAAA,CAAQ;AAClB,QAAA,CAAC;AAED,QAAA,IAAA,CAAA,gBAAgB,GAA+B,CAAC,IAAI,KAAI;AACtD,YAAA,OAAO,gBAAgB,CAAC,EAAE,GAAG,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,EAAE,EAAS,CAAC;AAC5D,QAAA,CAAC;AAED,QAAA,IAAA,CAAA,gBAAgB,GAA+B,CAAC,IAAI,KAAI;AACtD,YAAA,OAAO,gBAAgB,CAAC,EAAE,GAAG,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,EAAE,EAAS,CAAC;AAC5D,QAAA,CAAC;QAED,IAAA,CAAA,cAAc,GAAG,MAAmC;YAClD,OAAO,cAAc,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC,QAAQ,EAAE,CAAC;AAChD,QAAA,CAAC;IAzCD;AA0CD;AAEK,SAAU,WAAW,CAwBzB,OAgBC,EAAA;AAoBD,IAAA,OAAO,IAAI,KAAK,CAkBd,OAAO,CAAC;AACZ;SAegB,0BAA0B,GAAA;IACxC,OAAO,CAUL,OAUC,KACC;AACF,QAAA,OAAO,eAAe,CAUpB,OAAc,CAAC;AACnB,IAAA,CAAC;AACH;AAEA;;AAEG;AACI,MAAM,oBAAoB,GAAG;AAE9B,MAAO,SAaX,SAAQ,aAYP,CAAA;AAgBD;;AAEG;AACH,IAAA,WAAA,CACE,OAUC,EAAA;QAED,KAAK,CAAC,OAAO,CAAC;AAGhB,QAAA,IAAA,CAAA,WAAW,GAAkC,CAAC,IAAU,KAAI;AAC1D,YAAA,OAAO,WAAW,CAAC;gBACjB,MAAM,EAAE,IAAI,EAAE,MAAM;gBACpB,IAAI,EAAE,IAAI,CAAC,EAAE;AACP,aAAA,CAAQ;AAClB,QAAA,CAAC;AAED,QAAA,IAAA,CAAA,kBAAkB,GAAyC,CAAC,IAAI,KAAI;AAClE,YAAA,OAAO,WAAW,CAAC;AACjB,gBAAA,GAAG,IAAI;gBACP,IAAI,EAAE,IAAI,CAAC,EAAE;gBACb,MAAM,EAAE,CAAC,CAAC,MAAM,IAAI,EAAE,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC;AACnE,aAAA,CAAQ;AACX,QAAA,CAAC;AAED,QAAA,IAAA,CAAA,YAAY,GAAmC,CAAC,IAAI,KAAI;AACtD,YAAA,OAAO,YAAY,CAAC;gBAClB,MAAM,EAAE,IAAI,EAAE,MAAM;gBACpB,IAAI,EAAE,IAAI,CAAC,EAAE;AACP,aAAA,CAAQ;AAClB,QAAA,CAAC;AAED,QAAA,IAAA,CAAA,YAAY,GAAmC,CAAC,IAAI,KAAI;AACtD,YAAA,OAAO,YAAY,CAAC;gBAClB,MAAM,EAAE,IAAI,EAAE,MAAM;gBACpB,IAAI,EAAE,IAAI,CAAC,EAAE;AACP,aAAA,CAAQ;AAClB,QAAA,CAAC;AAED,QAAA,IAAA,CAAA,gBAAgB,GAAuC,CAAC,IAAI,KAAI;AAC9D,YAAA,OAAO,gBAAgB,CAAC,EAAE,GAAG,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,EAAE,EAAS,CAAC;AAC5D,QAAA,CAAC;AAED,QAAA,IAAA,CAAA,gBAAgB,GAAuC,CAAC,IAAI,KAAI;AAC9D,YAAA,OAAO,gBAAgB,CAAC,EAAE,GAAG,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,EAAE,EAAS,CAAC;AAC5D,QAAA,CAAC;QAED,IAAA,CAAA,cAAc,GAAG,MAA6B;YAC5C,OAAO,cAAc,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC,QAAQ,EAAE,CAAC;AAChD,QAAA,CAAC;IAzCD;AA0CD;AAEK,SAAU,eAAe,CAK7B,IAEqE,EAAA;AAErE,IAAA,OAAO,IAAW;AACpB;AAQM,MAAO,aAYX,SAAQ,KAiBT,CAAA;AACC,IAAA,WAAA,CACE,OAwBC,EAAA;AAED,QAAA,KAAK,CAAC;AACJ,YAAA,GAAI,OAAe;AACnB,YAAA,EAAE,EAAE,KAAK;AACV,SAAA,CAAC;IACJ;AACD;AAEK,SAAU,eAAe,CAW7B,OAUC,EAAA;AAcD,IAAA,OAAO,IAAI,SAAS,CAYlB,OAAO,CAAC;AACZ;;SClnBgB,qBAAqB,GAAA;AACnC,IAAA,MAAM,GAAG,GAAG,MAAM,CAAC,gBAAgB,CAAC;AACpC,IAAA,MAAM,MAAM,GAAG,MAAM,CAAC,QAAQ,CAAC;AAE/B,IAAA,MAAM,CAAC,UAAU,CAAC,CAAC,SAAS,CAAC,MAAK;QAChC,GAAG,CAAC,KAAK,EAAE;AACb,IAAA,CAAC,CAAC;IAEF,IAAI,aAAa,GAA0B,IAAI;IAC/C,IAAI,OAAO,GAAkB,IAAI;IAEjC,MAAM,KAAK,GAAG,MAAK;AACjB,QAAA,IAAI,aAAa;YAAE,GAAG,CAAC,KAAK,EAAE;QAC9B,aAAa,GAAG,IAAI;QACpB,OAAO,GAAG,IAAI;AAChB,IAAA,CAAC;IAED,OAAO;QACL,KAAK;AACL,QAAA,MAAM,EAAE,CAAC,EAAE,SAAS,EAAE,SAAS,GAAG,EAAE,EAAE,GAAG,EAAE,MAAM,EAAgB,KAAI;YACnE,IAAI,aAAa,KAAK,SAAS,IAAI,OAAO,KAAK,GAAG,EAAE;gBAClD;YACF;YAEA,GAAG,CAAC,KAAK,EAAE;AAEX,YAAA,IAAI,CAAC,SAAS;gBAAE;AAEhB,YAAA,MAAM,QAAQ,GAAG,QAAQ,CAAC,MAAM,CAAC,EAAE,SAAS,EAAE,MAAM,EAAE,CAAC;AACvD,YAAA,MAAM,QAAQ,GAAG,MAAM,CAAC,OAAO,CAAC,MAAM,IAAI,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,EAAE,KAAK,CAAC,KAC9D,YAAY,CAAC,IAAI,EAAE,KAAK,CAAC,CAC1B;AACD,YAAA,MAAM,MAAM,GAAG,GAAG,CAAC,eAAe,CAAC,SAAS,EAAE,EAAE,QAAQ,EAAE,QAAQ,EAAE,CAAC;AACrE,YAAA,MAAM,CAAC,iBAAiB,CAAC,YAAY,EAAE;YAEvC,aAAa,GAAG,SAAS;AACzB,YAAA,OAAO,GAAG,GAAG,IAAI,IAAI;QACvB,CAAC;KACF;AACH;;MCpDa,wBAAwB,CAAA;8GAAxB,wBAAwB,EAAA,IAAA,EAAA,EAAA,EAAA,MAAA,EAAA,EAAA,CAAA,eAAA,CAAA,SAAA,EAAA,CAAA,CAAA;AAAxB,IAAA,SAAA,IAAA,CAAA,IAAA,GAAA,EAAA,CAAA,oBAAA,CAAA,EAAA,UAAA,EAAA,QAAA,EAAA,OAAA,EAAA,QAAA,EAAA,IAAA,EAAA,wBAAwB,wHAJzB,CAAA,gBAAA,CAAkB,EAAA,QAAA,EAAA,IAAA,EAAA,eAAA,EAAA,EAAA,CAAA,uBAAA,CAAA,MAAA,EAAA,CAAA,CAAA;;2FAIjB,wBAAwB,EAAA,UAAA,EAAA,CAAA;kBALpC,SAAS;AAAC,YAAA,IAAA,EAAA,CAAA;AACT,oBAAA,QAAQ,EAAE,CAAA,gBAAA,CAAkB;oBAC5B,eAAe,EAAE,uBAAuB,CAAC,MAAM;AAC/C,oBAAA,IAAI,EAAE,EAAE,KAAK,EAAE,oBAAoB,EAAE;AACtC,iBAAA;;;ACkBD;AACA;AACA;AAEA;AACA,SAAS,gBAAgB,CAAC,EACxB,aAAa,EACb,WAAW,GAIZ,EAAA;IACC,MAAM,MAAM,GAAG,YAAY,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC;IAE5C,MAAM,QAAQ,GAAG,iBAAiB,CAAC;AACjC,QAAA,MAAM,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,gBAAgB,EAAE,KAAK,CAAC,GAAG;AAC7C,KAAA,CAAC;AAEF,IAAA,MAAM,WAAW,GAAG,QAAQ,CAAC,MAAM,aAAa,EAAE,KAAK,WAAW,EAAE,uDAAC;IAErE,MAAM,CAAC,MAAK;QACV,IAAI,CAAC,WAAW,EAAE;YAAE;QACpB,QAAQ,EAAE,CAAA;QAEV,MAAM,CAAC,IAAI,CAAC;AACV,YAAA,IAAI,EAAE,YAAY;AAClB,YAAA,GAAG,qBAAqB,CAAC,MAAM,CAAC,KAAK,CAAC;AACvC,SAAA,CAAC;AACJ,IAAA,CAAC,CAAC;AACJ;MAUa,UAAU,CAAA;AARvB,IAAA,WAAA,GAAA;AASE,QAAA,IAAA,CAAA,OAAO,GAAG,KAAK,CAAC,QAAQ,kDAAU;QAElC,IAAA,CAAA,MAAM,GAAG,YAAY,EAAE;QAEvB,IAAA,CAAA,SAAS,GAAG,iBAAiB,CAAC;AAC5B,YAAA,MAAM,EAAE,CAAC,CAAC,KAAI;gBACZ,MAAM,UAAU,GAAG,CAAC,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,IAAI,CAAC,OAAO,EAAE,CAAC;gBACtE,IAAI,UAAU,KAAK,CAAC,CAAC;AAAE,oBAAA,OAAO,IAAI;gBAElC,MAAM,KAAK,GAAG,CAAC,CAAC,OAAO,CAAC,UAAU,CAAE;gBACpC,MAAM,aAAa,GACjB,UAAU,GAAG,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,UAAU,GAAG,CAAC,CAAC,EAAE,OAAO,GAAG,IAAI;AAE5D,gBAAA,MAAM,OAAO,GAAG,KAAK,CAAC,OAAO;gBAC7B,MAAM,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,OAAO,CAAa;AACzD,gBAAA,MAAM,SAAS,GACb,KAAK,CAAC,OAAO,CAAC,WAAW,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,kBAAkB;AAErE,gBAAA,MAAM,WAAW,GAAG,SAAS,GAAG;oBAC9B,OAAO;oBACP,UAAU,EAAE,KAAK,CAAC,UAAU;oBAC5B,MAAM,EAAE,KAAK,CAAC,aAAa;oBAC3B,MAAM,EAAE,KAAK,CAAC,aAAa;AAC5B,iBAAA,CAAC;AACF,gBAAA,MAAM,GAAG,GAAG,WAAW,GAAG,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,GAAG,SAAS;gBAEjE,OAAO;oBACL,GAAG;oBACH,KAAK;oBACL,KAAK;oBACL,aAAa;iBACd;YACH,CAAC;AACF,SAAA,CAAC;AAEF,QAAA,IAAA,CAAA,sBAAsB,GAAG,QAAQ,CAC/B,MAAM,IAAI,CAAC,SAAS,EAAE,EAAE,aAAa,KAAK,WAAW,kEACtD;AAED,QAAA,IAAA,CAAA,aAAa,GAAG,QAAQ,CAAC,MAAK;YAC5B,MAAM,KAAK,GAAG,IAAI,CAAC,SAAS,EAAE,EAAE,KAAK;AACrC,YAAA,IAAI,CAAC,KAAK;AAAE,gBAAA,OAAO,IAAI;YACvB,OAAO,KAAK,CAAC,GAAG,KAAK,KAAK,IAAI,KAAK,CAAC,GAAG,KAAK,WAAW;AACzD,QAAA,CAAC,yDAAC;AAEF,QAAA,IAAA,CAAA,gBAAgB,GAAG,QAAQ,CAAC,MAAK;YAC/B,MAAM,KAAK,GAAG,IAAI,CAAC,SAAS,EAAE,EAAE,KAAK;AACrC,YAAA,IAAI,CAAC,KAAK;AAAE,gBAAA,OAAO,IAAI;YACvB,OAAO,IAAI,CAAC,aAAa,EAAE,IAAI,CAAC,CAAC,KAAK,CAAC,eAAe;AACxD,QAAA,CAAC,4DAAC;QAEF,IAAA,CAAA,SAAS,GAAG,qBAAqB,EAAE;AAEnC,QAAA,IAAA,CAAA,MAAM,GAAG,MAAM,CAAC,MAAK;AACnB,YAAA,MAAM,SAAS,GAAG,IAAI,CAAC,SAAS,EAAE;AAClC,YAAA,IAAI,CAAC,SAAS;gBAAE;YAEhB,IAAI,IAAI,CAAC,gBAAgB,EAAE,IAAI,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE;AACnD,gBAAA,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE;gBACtB;YACF;AAEA,YAAA,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,GAAG,SAAS;AAElC,YAAA,IAAI,KAAK,CAAC,MAAM,KAAK,UAAU,EAAE;gBAC/B,MAAM,iBAAiB,GAAG,oBAAoB,CAAC,IAAI,CAAC,MAAM,EAAE,KAAK,CAAC;gBAElE,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,EAAE,SAAS,EAAE,iBAAiB,EAAE,CAAC;YACzD;AAAO,iBAAA,IAAI,KAAK,CAAC,MAAM,KAAK,OAAO,EAAE;AACnC,gBAAA,MAAM,mBAAmB,GACvB,KAAK,CAAC,OAAO,CAAC,cAAc;AAC5B,oBAAA,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,qBAAqB;AAE3C,gBAAA,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC;oBACpB,SAAS,EAAE,mBAAmB,IAAI,IAAI;AACtC,oBAAA,MAAM,EAAE;AACN,wBAAA,KAAK,EAAE,MAAM,KAAK,CAAC,KAAK;wBACxB,KAAK,EAAE,MAAK;AACV,4BAAA,IAAI,CAAC,MAAM,CAAC,UAAU,EAAE;wBAC1B,CAAC;wBACD,IAAI,EAAE,MAAK;AACT,4BAAA,OAAO,EAAE,cAAc,EAAE,EAAE,EAAE;wBAC/B,CAAC;AACF,qBAAA;AACF,iBAAA,CAAC;YACJ;iBAAO,IACL,KAAK,CAAC,aAAa;AACnB,gBAAA,KAAK,CAAC,eAAe;gBACrB,KAAK,CAAC,MAAM,KAAK,YAAY;AAC7B,gBAAA,KAAK,CAAC,MAAM,KAAK,SAAS,EAC1B;AACA,gBAAA,MAAM,YAAY,GAChB,KAAK,CAAC,OAAO,CAAC,YAAY,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,mBAAmB;;;;AAKvE,gBAAA,IACE,KAAK,CAAC,MAAM,KAAK,SAAS;oBAC1B,YAAY;AACZ,oBAAA,CAAC,KAAK,CAAC,YAAY,CAAC,iBAAiB;AACrC,oBAAA,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,EACrB;AACA,oBAAA,MAAM,iBAAiB,GAAG,uBAAuB,EAAQ;AAEzD,oBAAA,KAAK,CAAC,YAAY,CAAC,iBAAiB,GAAG,iBAAiB;oBAExD,UAAU,CAAC,MAAK;wBACd,iBAAiB,CAAC,OAAO,EAAE;AAC3B,wBAAA,KAAK,CAAC,YAAY,CAAC,iBAAiB,GAAG,SAAS;oBAClD,CAAC,EAAE,YAAY,CAAC;gBAClB;AAEA,gBAAA,MAAM,gBAAgB,GACpB,KAAK,CAAC,OAAO,CAAC,gBAAgB;AAC9B,oBAAA,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,uBAAuB;gBAE7C,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,EAAE,SAAS,EAAE,gBAAgB,EAAE,CAAC;YACxD;AAAO,iBAAA,IAAI,KAAK,CAAC,MAAM,KAAK,SAAS,EAAE;AACrC,gBAAA,MAAM,SAAS,GACb,KAAK,CAAC,OAAO,CAAC,SAAS;AACvB,oBAAA,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,gBAAgB;AACpC,oBAAA,MAAM;AAER,gBAAA,MAAM,GAAG,GAAG,SAAS,CAAC,GAAG;AAEzB,gBAAA,MAAM,aAAa,GAAG,QAAQ,CAAC,MAAM,IAAI,CAAC,OAAO,EAAE,CAAC;AACpD,gBAAA,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC;oBACpB,GAAG;AACH,oBAAA,SAAS,EAAE,SAAS;AACpB,oBAAA,SAAS,EAAE;AACT,wBAAA;AACE,4BAAA,OAAO,EAAE,uBAAuB;AAChC,4BAAA,QAAQ,EAAE,aAAa;AACxB,yBAAA;AACF,qBAAA;AACF,iBAAA,CAAC;YACJ;AACF,QAAA,CAAC,kDAAC;AACH,IAAA;8GA5IY,UAAU,EAAA,IAAA,EAAA,EAAA,EAAA,MAAA,EAAA,EAAA,CAAA,eAAA,CAAA,SAAA,EAAA,CAAA,CAAA;AAAV,IAAA,SAAA,IAAA,CAAA,IAAA,GAAA,EAAA,CAAA,oBAAA,CAAA,EAAA,UAAA,EAAA,QAAA,EAAA,OAAA,EAAA,QAAA,EAAA,IAAA,EAAA,UAAU,6QANX,EAAE,EAAA,QAAA,EAAA,IAAA,EAAA,CAAA,CAAA;;2FAMD,UAAU,EAAA,UAAA,EAAA,CAAA;kBARtB,SAAS;AAAC,YAAA,IAAA,EAAA,CAAA;AACT,oBAAA,QAAQ,EAAE,cAAc;AACxB,oBAAA,QAAQ,EAAE,EAAE;AACZ,oBAAA,UAAU,EAAE,IAAI;AAChB,oBAAA,IAAI,EAAE;AACJ,wBAAA,qBAAqB,EAAE,WAAW;AACnC,qBAAA;AACF,iBAAA;;MAoJY,MAAM,CAAA;AALnB,IAAA,WAAA,GAAA;QAME,IAAA,CAAA,MAAM,GAAG,YAAY,EAAE;AACvB,QAAA,IAAA,CAAA,OAAO,GAAG,MAAM,CAAC,uBAAuB,CAAC;QAEzC,IAAA,CAAA,OAAO,GAAG,iBAAiB,CAAC;YAC1B,MAAM,EAAE,CAAC,CAAC,KACR,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,IAAI,CAAC,OAAO,EAAE,CAAC,EAAE,OAAiB;AACpE,SAAA,CAAC;AAEF,QAAA,IAAA,CAAA,KAAK,GAAG,QAAQ,CAAC,MAAM,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,OAAO,EAAE,CAAa,iDAAC;QAE1E,IAAA,CAAA,oBAAoB,GAAG,iBAAiB,CAAC;AACvC,YAAA,MAAM,EAAE,CAAC,CAAC,KAAI;AACZ,gBAAA,MAAM,OAAO,GAAG,CAAC,CAAC,OAAO;gBACzB,MAAM,WAAW,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,IAAI,CAAC,OAAO,EAAE,CAAC;AAChE,gBAAA,IAAI,CAAC,WAAW;AAAE,oBAAA,OAAO,KAAK;gBAC9B,OAAO,WAAW,CAAC,cAAc;YACnC,CAAC;AACF,SAAA,CAAC;QAEF,IAAA,CAAA,YAAY,GAAG,iBAAiB,CAAC;AAC/B,YAAA,MAAM,EAAE,CAAC,CAAC,KAAI;AACZ,gBAAA,MAAM,OAAO,GAAG,CAAC,CAAC,OAAO;gBACzB,MAAM,KAAK,GAAG,OAAO,CAAC,SAAS,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,IAAI,CAAC,OAAO,EAAE,CAAC;gBAC/D,MAAM,KAAK,GAAG,OAAO,CAAC,KAAK,GAAG,CAAC,CAAC;AAChC,gBAAA,IAAI,CAAC,KAAK;AAAE,oBAAA,OAAO,IAAI;gBAEvB,OAAO,KAAK,CAAC,EAAE;YACjB,CAAC;AACF,SAAA,CAAC;QAEF,IAAA,CAAA,SAAS,GAAG,qBAAqB,EAAE;AAEnC,QAAA,IAAA,CAAA,MAAM,GAAG,MAAM,CAAC,MAAK;AACnB,YAAA,IAAI,IAAI,CAAC,oBAAoB,EAAE,EAAE;;AAE/B,gBAAA,MAAM,iBAAiB,GAAG,oBAAoB,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,KAAK,EAAE,CAAC;gBACzE,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,EAAE,SAAS,EAAE,iBAAiB,EAAE,CAAC;gBACvD;YACF;AACA,YAAA,MAAM,YAAY,GAAG,IAAI,CAAC,YAAY,EAAE;YAExC,IAAI,CAAC,YAAY,EAAE;;AAEjB,gBAAA,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE;gBACtB;YACF;AAEA,YAAA,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC;AACpB,gBAAA,SAAS,EAAE,UAAU;AACrB,gBAAA,MAAM,EAAE;AACN,oBAAA,OAAO,EAAE,MAAM,IAAI,CAAC,YAAY,EAAE;AACnC,iBAAA;AACF,aAAA,CAAC;AACJ,QAAA,CAAC,kDAAC;AACH,IAAA;8GAvDY,MAAM,EAAA,IAAA,EAAA,EAAA,EAAA,MAAA,EAAA,EAAA,CAAA,eAAA,CAAA,SAAA,EAAA,CAAA,CAAA;AAAN,IAAA,SAAA,IAAA,CAAA,IAAA,GAAA,EAAA,CAAA,oBAAA,CAAA,EAAA,UAAA,EAAA,QAAA,EAAA,OAAA,EAAA,QAAA,EAAA,IAAA,EAAA,MAAM,kEAHP,EAAE,EAAA,QAAA,EAAA,IAAA,EAAA,CAAA,CAAA;;2FAGD,MAAM,EAAA,UAAA,EAAA,CAAA;kBALlB,SAAS;AAAC,YAAA,IAAA,EAAA,CAAA;AACT,oBAAA,QAAQ,EAAE,QAAQ;AAClB,oBAAA,QAAQ,EAAE,EAAE;AACZ,oBAAA,UAAU,EAAE,IAAI;AACjB,iBAAA;;AA0DD,SAAS,oBAAoB,CAAC,MAAiB,EAAE,KAAe,EAAA;AAC9D,IAAA,IAAI,iBAAiB,GACnB,KAAK,CAAC,OAAO,CAAC,iBAAiB,IAAI,MAAM,CAAC,OAAO,CAAC,wBAAwB;IAE5E,IAAI,iBAAiB,EAAE;AACrB,QAAA,OAAO,iBAAiB;IAC1B;IAEA,IAAI,OAAO,CAAC,GAAG,CAAC,QAAQ,KAAK,aAAa,EAAE;AAC1C,QAAA,OAAO,CACL,KAAK,CAAC,OAAO,CAAC,iBAAiB,EAC/B,CAAA,sDAAA,EAAyD,KAAK,CAAC,EAAE,CAAA,uPAAA,CAAyP,CAC3T;IACH;AAEA,IAAA,OAAO,wBAAwB;AACjC;;AC1QA;AACA,IAAI,kBAAkB,GAAmD;AACvE,IAAA,MAAM,EAAE,IAAI;AACZ,IAAA,OAAO,EAAE,KAAK;CACf;AAED;;;;;;;;;AASG;SACa,uBAAuB,GAAA;AACrC,IAAA,MAAM,MAAM,GAAG,YAAY,EAAE;;AAG7B,IAAA,IAAI,MAAM,CAAC,QAAQ,EAAE;QACnB;IACF;AAEA,IAAA,MAAM,UAAU,GAAG,MAAM,CAAC,UAAU,CAAC;IAErC,MAAM,SAAS,GAAG,iBAAiB,CAAC;QAClC,MAAM,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,SAAS;AAC3B,KAAA,CAAC;;AAGF,IAAA,MAAM,eAAe,GAAG,MAAM,CAAC,KAAK,2DAAC;;IAGrC,MAAM,iBAAiB,GAAG,iBAAiB,CAAC;QAC1C,MAAM,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,MAAM,KAAK,SAAS,CAAC;AAC7D,KAAA,CAAC;;AAGF,IAAA,IAAI,iBAAsC;AAC1C,IAAA,IAAI,oBAAyC;AAC7C,IAAA,IAAI,qBAA0C;AAE9C,IAAA,MAAM,YAAY,GAAG,QAAQ,CAC3B,MAAM,SAAS,EAAE,IAAI,eAAe,EAAE,IAAI,iBAAiB,EAAE,wDAC9D;AAED,IAAA,MAAM,aAAa,GAAG,QAAQ,CAAC,MAAM,SAAS,EAAE,IAAI,iBAAiB,EAAE,yDAAC;;;AAIxE,IAAA,MAAM,CAAC,eAAe,GAAG,CAAC,EAA8B,KAAI;AAC1D,QAAA,eAAe,CAAC,GAAG,CAAC,IAAI,CAAC;;AAEzB,QAAA,IAAI;YACF,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,MAAM,EAAE,GAAG,CAAC,EAAE,eAAe,EAAE,IAAI,EAAE,CAAC,CAAC;QACnE;AAAE,QAAA,MAAM;;QAER;;AAGA,QAAA,MAAM,MAAM,GAAG,EAAE,EAAE;;AAGnB,QAAA,IAAI,MAAM,YAAY,OAAO,EAAE;YAC7B;iBACG,IAAI,CAAC,MAAK;AACT,gBAAA,eAAe,CAAC,GAAG,CAAC,KAAK,CAAC;AAC1B,gBAAA,IAAI;oBACF,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,MAAM,EAAE,GAAG,CAAC,EAAE,eAAe,EAAE,KAAK,EAAE,CAAC,CAAC;gBACpE;AAAE,gBAAA,MAAM;;gBAER;AACF,YAAA,CAAC;iBACA,KAAK,CAAC,MAAK;AACV,gBAAA,eAAe,CAAC,GAAG,CAAC,KAAK,CAAC;AAC1B,gBAAA,IAAI;oBACF,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,MAAM,EAAE,GAAG,CAAC,EAAE,eAAe,EAAE,KAAK,EAAE,CAAC,CAAC;gBACpE;AAAE,gBAAA,MAAM;;gBAER;AACF,YAAA,CAAC,CAAC;QACN;aAAO;;YAEL,UAAU,CAAC,MAAK;AACd,gBAAA,eAAe,CAAC,GAAG,CAAC,KAAK,CAAC;AAC1B,gBAAA,IAAI;oBACF,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,MAAM,EAAE,GAAG,CAAC,EAAE,eAAe,EAAE,KAAK,EAAE,CAAC,CAAC;gBACpE;AAAE,gBAAA,MAAM;;gBAER;YACF,CAAC,EAAE,CAAC,CAAC;QACP;AACF,IAAA,CAAC;;;AAID,IAAA,MAAM,2BAA2B,GAG9B,MAAc,CAAC,gCAAgC;QAChD,MAAM,CAAC,mBAAmB;AAE1B,IAAA,MAAc,CAAC,gCAAgC;AAC/C,QAAA,2BAA2B;AAE7B,IAAA,MAAM,CAAC,mBAAmB,GAAG,CAAC,EAAuB,KAAI;AACvD,QAAA,OAAO,2BAA2B,GAAG,EAAE,CAAC;AAC1C,IAAA,CAAC;;AAGD,IAAA,IAAI,WAAqC;IAEzC,eAAe,CAAC,MAAK;QACnB,WAAW,GAAG,MAAM,CAAC,OAAO,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC;AAEnD,QAAA,MAAM,YAAY,GAAG,MAAM,CAAC,aAAa,CAAC;AACxC,YAAA,EAAE,EAAE,MAAM,CAAC,cAAc,CAAC,QAAQ;AAClC,YAAA,MAAM,EAAE,IAAI;AACZ,YAAA,MAAM,EAAE,IAAI;AACZ,YAAA,IAAI,EAAE,IAAI;AACV,YAAA,KAAK,EAAE,IAAI;AACX,YAAA,sBAAsB,EAAE,IAAI;AAC7B,SAAA,CAAC;AAEF,QAAA,IACE,aAAa,CAAC,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC;AACzC,YAAA,aAAa,CAAC,YAAY,CAAC,IAAI,CAAC,EAChC;AACA,YAAA,MAAM,CAAC,cAAc,CAAC,EAAE,GAAG,YAAY,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC;QAC3D;AACF,IAAA,CAAC,CAAC;;AAGF,IAAA,MAAM,SAAS,GAAG,MAAM,CAAC,KAAK,qDAAC;IAE/B,eAAe,CAAC,MAAK;AACnB,QAAA,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC;AACnB,QAAA,IAAI,CAAC,YAAY,EAAE,EAAE;AACnB,YAAA,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,KACxB,CAAC,CAAC,MAAM,KAAK;AACX,kBAAE,EAAE,GAAG,CAAC,EAAE,MAAM,EAAE,MAAM,EAAE,gBAAgB,EAAE,CAAC,CAAC,QAAQ;kBACpD,CAAC,CACN;QACH;AACF,IAAA,CAAC,CAAC;AAEF,IAAA,UAAU,CAAC,SAAS,CAAC,MAAK;AACxB,QAAA,SAAS,CAAC,GAAG,CAAC,KAAK,CAAC;QACpB,IAAI,WAAW,EAAE;AACf,YAAA,WAAW,EAAE;QACf;AACF,IAAA,CAAC,CAAC;;IAGF,eAAe,CAAC,MAAK;QACnB,IACE,CAAC,OAAO,MAAM,KAAK,WAAW,IAAI,MAAM,CAAC,GAAG;aAC3C,kBAAkB,CAAC,MAAM,KAAK,MAAM,IAAI,kBAAkB,CAAC,OAAO,CAAC,EACpE;YACA;QACF;QACA,kBAAkB,GAAG,EAAE,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE;AAC9C,QAAA,MAAM,OAAO,GAAG,YAAW;AACzB,YAAA,IAAI;AACF,gBAAA,MAAM,MAAM,CAAC,IAAI,EAAE;YACrB;YAAE,OAAO,GAAG,EAAE;AACZ,gBAAA,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC;YACpB;AACF,QAAA,CAAC;AACD,QAAA,OAAO,EAAE;AACX,IAAA,CAAC,CAAC;;;;IAMF,MAAM,CAAC,MAAK;QACV,IAAI,CAAC,SAAS,EAAE;YAAE;AAClB,QAAA,MAAM,gBAAgB,GAAG,SAAS,EAAE;AACpC,QAAA,IAAI;AACF,YAAA,IAAI,iBAAiB,IAAI,CAAC,gBAAgB,EAAE;gBAC1C,MAAM,CAAC,IAAI,CAAC;AACV,oBAAA,IAAI,EAAE,QAAQ;AACd,oBAAA,GAAG,qBAAqB,CAAC,MAAM,CAAC,KAAK,CAAC;AACvC,iBAAA,CAAC;YACJ;YACA,iBAAiB,GAAG,gBAAgB;QACtC;AAAE,QAAA,MAAM;;QAER;AACF,IAAA,CAAC,CAAC;;IAGF,MAAM,CAAC,MAAK;QACV,IAAI,CAAC,SAAS,EAAE;YAAE;AAClB,QAAA,MAAM,oBAAoB,GAAG,aAAa,EAAE;AAC5C,QAAA,IAAI;AACF,YAAA,IAAI,qBAAqB,IAAI,CAAC,oBAAoB,EAAE;gBAClD,MAAM,CAAC,IAAI,CAAC;AACV,oBAAA,IAAI,EAAE,oBAAoB;AAC1B,oBAAA,GAAG,qBAAqB,CAAC,MAAM,CAAC,KAAK,CAAC;AACvC,iBAAA,CAAC;YACJ;YACA,qBAAqB,GAAG,oBAAoB;QAC9C;AAAE,QAAA,MAAM;;QAER;AACF,IAAA,CAAC,CAAC;;IAGF,MAAM,CAAC,MAAK;QACV,IAAI,CAAC,SAAS,EAAE;YAAE;AAClB,QAAA,MAAM,mBAAmB,GAAG,YAAY,EAAE;AAC1C,QAAA,IAAI;AACF,YAAA,IAAI,CAAC,mBAAmB,IAAI,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,MAAM,KAAK,SAAS,EAAE;gBACrE,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,MAAM;AAC9B,oBAAA,GAAG,CAAC;AACJ,oBAAA,MAAM,EAAE,MAAM;oBACd,gBAAgB,EAAE,CAAC,CAAC,QAAQ;AAC7B,iBAAA,CAAC,CAAC;YACL;;AAGA,YAAA,IAAI,oBAAoB,IAAI,CAAC,mBAAmB,EAAE;gBAChD,MAAM,UAAU,GAAG,qBAAqB,CAAC,MAAM,CAAC,KAAK,CAAC;gBACtD,MAAM,CAAC,IAAI,CAAC;AACV,oBAAA,IAAI,EAAE,YAAY;AAClB,oBAAA,GAAG,UAAU;AACd,iBAAA,CAAC;AAEF,gBAAA,IAAI,UAAU,CAAC,WAAW,EAAE;oBAC1B,gBAAgB,CAAC,MAAM,CAAC;gBAC1B;YACF;YACA,oBAAoB,GAAG,mBAAmB;QAC5C;AAAE,QAAA,MAAM;;QAER;AACF,IAAA,CAAC,CAAC;AACJ;;MC1Pa,OAAO,CAAA;AADpB,IAAA,WAAA,GAAA;QAEU,IAAA,CAAA,OAAO,GAAG,iBAAiB,CAAC;AAClC,YAAA,MAAM,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE;AAChC,SAAA,CAAC;QAEF,IAAA,CAAA,QAAQ,GAAG,qBAAqB,EAAE;QAClC,IAAA,CAAA,YAAY,GAAG,uBAAuB,EAAE;AAExC,QAAA,IAAA,CAAA,MAAM,GAAG,MAAM,CAAC,MAAK;AACnB,YAAA,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,EAAE;YAE9B,IAAI,CAAC,OAAO,EAAE;AACZ,gBAAA,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE;gBACrB;YACF;AAEA,YAAA,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC;AACnB,gBAAA,SAAS,EAAE,UAAU;AACrB,gBAAA,MAAM,EAAE;AACN,oBAAA,OAAO,EAAE,MAAM,OAAO;AACvB,iBAAA;AACF,aAAA,CAAC;AACJ,QAAA,CAAC,kDAAC;AACH,IAAA;8GAvBY,OAAO,EAAA,IAAA,EAAA,EAAA,EAAA,MAAA,EAAA,EAAA,CAAA,eAAA,CAAA,SAAA,EAAA,CAAA,CAAA;AAAP,IAAA,SAAA,IAAA,CAAA,IAAA,GAAA,EAAA,CAAA,oBAAA,CAAA,EAAA,UAAA,EAAA,QAAA,EAAA,OAAA,EAAA,QAAA,EAAA,IAAA,EAAA,OAAO,0EAD+B,EAAE,EAAA,QAAA,EAAA,IAAA,EAAA,CAAA,CAAA;;2FACxC,OAAO,EAAA,UAAA,EAAA,CAAA;kBADnB,SAAS;mBAAC,EAAE,QAAQ,EAAE,gBAAgB,EAAE,QAAQ,EAAE,EAAE,EAAE,UAAU,EAAE,IAAI,EAAE;;;MCC5D,cAAc,CAAA;AAD3B,IAAA,WAAA,GAAA;AAEE,QAAA,IAAA,CAAA,MAAM,GAAG,KAAK,CAAC,QAAQ,iDAAa;QACpC,IAAA,CAAA,QAAQ,GAAG,qBAAqB,EAAE;AAElC,QAAA,IAAA,CAAA,MAAM,GAAG,MAAM,CAAC,MAAK;YACnB,MAAM,MAAM,GAAG,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC;AACrC,YAAA,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC;AACnB,gBAAA,SAAS,EAAE,OAAO;AAClB,gBAAA,SAAS,EAAE;AACT,oBAAA;wBACE,OAAO,EAAE,qBAAqB,EAAE;AAChC,wBAAA,QAAQ,EAAE,MAAM;AACjB,qBAAA;AACF,iBAAA;AACF,aAAA,CAAC;AACJ,QAAA,CAAC,kDAAC;AACH,IAAA;8GAhBY,cAAc,EAAA,IAAA,EAAA,EAAA,EAAA,MAAA,EAAA,EAAA,CAAA,eAAA,CAAA,SAAA,EAAA,CAAA,CAAA;AAAd,IAAA,SAAA,IAAA,CAAA,IAAA,GAAA,EAAA,CAAA,oBAAA,CAAA,EAAA,UAAA,EAAA,QAAA,EAAA,OAAA,EAAA,QAAA,EAAA,IAAA,EAAA,cAAc,iNADyB,EAAE,EAAA,QAAA,EAAA,IAAA,EAAA,CAAA,CAAA;;2FACzC,cAAc,EAAA,UAAA,EAAA,CAAA;kBAD1B,SAAS;mBAAC,EAAE,QAAQ,EAAE,iBAAiB,EAAE,QAAQ,EAAE,EAAE,EAAE,UAAU,EAAE,IAAI,EAAE;;;ACWpE,SAAU,mBAAmB,CAMjC,IAAgE,EAAA;AAEhE,IAAA,OAAO,WAAW,CAAC;AACjB,QAAA,GAAG,IAAI;QACP,MAAM,EAAE,CAAC,KAAK,KACZ,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,KAAK,CAAC,OAAO;AAC3D,KAAA,CAAQ;AACX;;ACbM,SAAU,cAAc,CAI5B,IAA+C,EAAA;AAE/C,IAAA,OAAO,iBAAiB,CAAC;QACvB,MAAM,EAAE,CAAC,CAAC,MAAM,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,QAAQ,CAAC;AACpE,KAAA,CAAQ;AACX;;ACgEM,SAAU,aAAa,CAI3B,IAA+C,EAAA;AAE/C,IAAA,MAAM,aAAa,GAAG,IAAI,CAAC,aAAyC;AACpE,IAAA,MAAM,MAAM,GAAG,YAAY,EAAE;IAE7B,MAAM,QAAQ,GAAG,MAAM,CAAkB;AACvC,QAAA,MAAM,EAAE,MAAM;AACd,QAAA,OAAO,EAAE,SAAS;AAClB,QAAA,IAAI,EAAE,SAAS;AACf,QAAA,MAAM,EAAE,SAAS;AACjB,QAAA,OAAO,EAAE,SAAS;AAClB,QAAA,KAAK,EAAE,SAAS;AACjB,KAAA,EAAA,IAAA,SAAA,GAAA,CAAA,EAAA,SAAA,EAAA,UAAA,EAAA,CAAA,GAAA,EAAA,CAAA,CAAC;AAEF,IAAA,MAAM,CAAC,CAAC,SAAS,KAAI;AACnB,QAAA,MAAM,iBAAiB,GAAG,OAAO,aAA4B,KAAI;YAC/D,SAAS,WAAW,CAClB,QAAyB,EAAA;gBAEzB,MAAM,cAAc,GAAG,MAAM,CAAC,aAAa,CAAC,QAAQ,CAAC;gBACrD,MAAM,aAAa,GAAG,MAAM,CAAC,gBAAgB,CAAC,cAAc,CAAC,QAAQ,CAAC;AACtE,gBAAA,IAAI,aAAa,CAAC,UAAU,KAAK,SAAS,EAAE;oBAC1C,OAAO;AACL,wBAAA,OAAO,EAAE,cAAc;wBACvB,QAAQ,EAAE,cAAc,CAAC,QAAQ;wBACjC,QAAQ,EAAE,cAAc,CAAC,QAAQ;wBACjC,MAAM,EAAE,aAAa,CAAC,WAAW;wBACjC,MAAM,EAAE,cAAc,CAAC,MAAM;qBAC9B;gBACH;gBACA,OAAO;AACL,oBAAA,OAAO,EAAE,aAAa,CAAC,UAAU,CAAC,EAAE;AACpC,oBAAA,QAAQ,EAAE,aAAa,CAAC,UAAU,CAAC,QAAQ;oBAC3C,QAAQ,EAAE,cAAc,CAAC,QAAQ;oBACjC,MAAM,EAAE,aAAa,CAAC,WAAW;oBACjC,MAAM,EAAE,cAAc,CAAC,MAAM;iBAC9B;YACH;YAEA,MAAM,OAAO,GAAG,WAAW,CAAC,aAAa,CAAC,eAAe,CAAC;YAC1D,MAAM,IAAI,GAAG,WAAW,CAAC,aAAa,CAAC,YAAY,CAAC;AAEpD,YAAA,IACE,OAAO,CAAC,OAAO,KAAK,cAAc;AAClC,gBAAA,IAAI,CAAC,OAAO,KAAK,cAAc,EAC/B;AACA,gBAAA,OAAO,KAAK;YACd;AAEA,YAAA,MAAM,WAAW,GAAG,MAAM,aAAa,CAAC;gBACtC,MAAM,EAAE,aAAa,CAAC,MAAM;gBAC5B,OAAO;gBACP,IAAI;AACL,aAAA,CAAC;AACF,YAAA,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE;AACtB,gBAAA,OAAO,WAAW;YACpB;YAEA,IAAI,CAAC,WAAW,EAAE;AAChB,gBAAA,OAAO,KAAK;YACd;YAEA,MAAM,OAAO,GAAG,IAAI,OAAO,CAAU,CAAC,OAAO,KAAI;gBAC/C,QAAQ,CAAC,GAAG,CAAC;AACX,oBAAA,MAAM,EAAE,SAAS;oBACjB,OAAO;oBACP,IAAI;oBACJ,MAAM,EAAE,aAAa,CAAC,MAAM;AAC5B,oBAAA,OAAO,EAAE,MAAM,OAAO,CAAC,KAAK,CAAC;AAC7B,oBAAA,KAAK,EAAE,MAAM,OAAO,CAAC,IAAI,CAAC;AAC3B,iBAAA,CAAC;AACJ,YAAA,CAAC,CAAC;AAEF,YAAA,MAAM,gBAAgB,GAAG,MAAM,OAAO;YACtC,QAAQ,CAAC,GAAG,CAAC;AACX,gBAAA,MAAM,EAAE,MAAM;AACd,gBAAA,OAAO,EAAE,SAAS;AAClB,gBAAA,IAAI,EAAE,SAAS;AACf,gBAAA,MAAM,EAAE,SAAS;AACjB,gBAAA,OAAO,EAAE,SAAS;AAClB,gBAAA,KAAK,EAAE,SAAS;AACjB,aAAA,CAAC;AAEF,YAAA,OAAO,gBAAgB;AACzB,QAAA,CAAC;AAED,QAAA,MAAM,YAAY,GAAG,IAAI,CAAC;AACxB,cAAE;AACF,cAAE,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC;AACnB,gBAAA,SAAS,EAAE,iBAAiB;gBAC5B,kBAAkB,EAAE,IAAI,CAAC,kBAAkB;AAC5C,aAAA,CAAC;QAEN,SAAS,CAAC,MAAM,YAAY,IAAI,CAAC;AACnC,IAAA,CAAC,CAAC;AAEF,IAAA,OAAO,QAAQ,CAAC,UAAU,EAAS;AACrC;;SC7LgB,eAAe,GAAA;AAC7B,IAAA,OAAO,iBAAiB,CAAC;AACvB,QAAA,MAAM,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,WAAW,KAAK,CAAC;AAClD,KAAA,CAAC;AACJ;;SCCgB,0BAA0B,CACxC,QAAgE,EAChE,2BAAqD,EACrD,QAAuB,EAAA;AAEvB,IAAA,MAAM,UAAU,GAAG,MAAM,CAAC,UAAU,CAAC;AAErC,IAAA,iBAAiB,CAAC,CAAC,SAAS,KAAI;AAC9B,QAAA,MAAM,UAAU,GAAG,QAAQ,EAAE;AAC7B,QAAA,MAAM,OAAO,GAAG,UAAU,CAAC,aAAmC;QAC9D,IAAI,UAAU,IAAI,CAAC,OAAO;YAAE;AAE5B,QAAA,MAAM,QAAQ,GAAG,IAAI,oBAAoB,CACvC,CAAC,CAAC,KAAK,CAAC,KAAK,QAAQ,CAAC,KAAK,CAAC,EAC5B,2BAA2B,CAC5B;AAED,QAAA,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC;QAEzB,SAAS,CAAC,MAAK;YACb,QAAQ,CAAC,UAAU,EAAE;AACvB,QAAA,CAAC,CAAC;AACJ,IAAA,CAAC,CAAC;AACJ;;AC9BA;;ACAA;;AAEG;;;;\"}","type":"asset"}]}